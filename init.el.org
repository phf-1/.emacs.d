#+PROPERTY: header-args:emacs-lisp :tangle init.el :comments org

* package.el

#+begin_src emacs-lisp
(require 'package)
(add-to-list 'package-archives '("melpa" . "https://melpa.org/packages/") t)
(package-initialize)
#+end_src

* Local packages

#+begin_src emacs-lisp
(defvar user--packages (file-name-as-directory (concat user-emacs-directory "elisp"))
  "Where users adds its elisp files and packages.")
(add-to-list 'load-path user--packages)
#+end_src

* Package configuration

#+begin_src emacs-lisp
(eval-when-compile (require 'use-package))
#+end_src

* emacs

** calendar
:PROPERTIES:
:header-args:emacs-lisp: :tangle calendar.el
:END:

#+begin_src emacs-lisp
(setq calendar-week-start-day 1)
(setq holiday-bahai-holidays nil)
(setq holiday-hebrew-holidays nil)
(setq holiday-islamic-holidays nil)
(setq holiday-oriental-holidays nil)
#+end_src

** editing
:PROPERTIES:
:header-args:emacs-lisp: :tangle editing.el
:END:

#+begin_src emacs-lisp
;; (add-hook 'before-save-hook #'whitespace-cleanup)
(setq-default indent-tabs-mode nil)
(put 'downcase-region 'disabled nil)
(put 'upcase-region 'disabled nil)
(delete-selection-mode 1)
(global-auto-revert-mode t)
(put 'narrow-to-region 'disabled nil)
(setq load-prefer-newer t)
#+end_src

** ui
:PROPERTIES:
:header-args:emacs-lisp: :tangle ui.el
:END:

#+begin_src emacs-lisp
(scroll-bar-mode -1)
(tool-bar-mode -1)
(menu-bar-mode 1)
(setq-default cursor-type 'bar)
(setq-default fill-column 85)
(column-number-mode 1)
(setq frame-title-format '("%b"))
(fset 'yes-or-no-p 'y-or-n-p)
(setq ring-bell-function 'ignore)
(add-to-list 'default-frame-alist '(font . "JetBrains Mono"))
#+end_src

** startup
:PROPERTIES:
:header-args:emacs-lisp: :tangle startup.el
:END:

#+begin_src emacs-lisp
(setq inhibit-startup-screen t)
(setq initial-scratch-message "")
#+end_src

** buffer
:PROPERTIES:
:header-args:emacs-lisp: :tangle buffer.el
:END:

#+begin_src emacs-lisp
(setq uniquify-buffer-name-style 'post-forward)
(setq uniquify-strip-common-suffix nil)
#+end_src

** mini-buffer
:PROPERTIES:
:header-args:emacs-lisp: :tangle mini-buffer.el
:END:

#+begin_src emacs-lisp
(setq enable-recursive-minibuffers t)
#+end_src

** external-processes
:PROPERTIES:
:header-args:emacs-lisp: :tangle external-processes.el
:END:

#+begin_src emacs-lisp
(setq read-process-output-max (* 1024 1024))
#+end_src

** backup
:PROPERTIES:
:header-args:emacs-lisp: :tangle backup.el
:END:

#+begin_src emacs-lisp
(defconst emacs-tmp-dir (expand-file-name (format "emacs%d" (user-uid)) temporary-file-directory))
(setq create-lockfiles nil)
(setq delete-by-moving-to-trash t)
(setq
 backup-by-copying t
 delete-old-versions t
 kept-new-versions 6
 kept-old-versions 2
 version-control t
 auto-save-list-file-prefix emacs-tmp-dir
 auto-save-file-name-transforms `((".*" ,emacs-tmp-dir t))
 backup-directory-alist `((".*" . ,emacs-tmp-dir)))
#+end_src

** key-bindings
:PROPERTIES:
:header-args:emacs-lisp: :tangle key-bindings.el
:END:

#+begin_src emacs-lisp
(global-set-key (kbd "C-$") #'clone-indirect-buffer-other-window)
(global-set-key (kbd "C-c l") #'org-store-link)
#+end_src

** utils
:PROPERTIES:
:header-args:emacs-lisp: :tangle utils.el
:END:

#+begin_src emacs-lisp
(defun unfill-paragraph (&optional region)
  "Takes a multi-line paragraph and makes it into a single line of text."

  (interactive (progn (barf-if-buffer-read-only) '(t)))
  (let ((fill-column (point-max))
        ;; This would override `fill-column' if it's an integer.
        (emacs-lisp-docstring-fill-column t))
    (fill-paragraph nil region)))

(defun dedicate-window (&optional arg)
  "Set current window to be dedicated.
With prefix ARG, undedicate it."
  (interactive "P")
  (set-window-dedicated-p (get-buffer-window (current-buffer)) (not arg))
  (message (if arg
               "Window '%s' is normal"
             "Window '%s' is dedicated")
           (current-buffer)))
#+end_src

** configuration

#+begin_src emacs-lisp
(use-package emacs :demand
  :init
  (load (concat user-emacs-directory "calendar.el"))
  (load (concat user-emacs-directory "editing.el"))
  (load (concat user-emacs-directory "ui.el"))
  (load (concat user-emacs-directory "startup.el"))
  (load (concat user-emacs-directory "buffer.el"))
  (load (concat user-emacs-directory "mini-buffer.el"))
  (load (concat user-emacs-directory "external-processes.el"))
  (load (concat user-emacs-directory "backup.el"))
  (load (concat user-emacs-directory "key-bindings.el"))
  (load (concat user-emacs-directory "utils.el")))
#+end_src

* gcmh
See: https://akrl.sdf.org/#orgc15a10d

#+begin_src emacs-lisp
(use-package gcmh :demand
  :config
  (setq gcmh-verbose t)
  (gcmh-mode))
#+end_src

* recentf

#+begin_src emacs-lisp
(use-package recentf :demand
  :config
  (recentf-mode)
  (setq recentf-max-menu-items 20)
  (setq recentf-max-saved-items 20)
  (run-at-time nil (* 5 60) 'recentf-save-list))
#+end_src

* dired

#+begin_src emacs-lisp
(use-package dired :demand
  :hook (dired-mode . dired-hide-details-mode)
  :config
  (setq dired-dwim-target t))
#+end_src

* paren

#+begin_src emacs-lisp
(use-package paren :demand
  :config
  (show-paren-mode 1))
#+end_src

* elec-pair

#+begin_src emacs-lisp
(use-package elec-pair :demand
  :config
  (electric-pair-mode 1))
#+end_src

* theme

#+begin_src emacs-lisp
(use-package modus-themes :demand
  :bind ([f12] . modus-themes-toggle)
  :config
  (setq modus-themes-hl-line  '(intense accented))
  (setq x-underline-at-descent-line t)
  (setq modus-themes-intense-markup t)
  (setq modus-themes-italic-constructs t
        modus-themes-bold-constructs nil
        modus-themes-region '(bg-only no-extend))
  (load-theme 'modus-vivendi :no-confirm))
#+end_src

* treesit

#+begin_src emacs-lisp
(use-package treesit :demand)
#+end_src

* treemacs

#+begin_src emacs-lisp
(use-package treemacs)
#+end_src

* hl-line

#+begin_src emacs-lisp
(use-package hl-line :demand
  :config
  (global-hl-line-mode 1))
#+end_src

* diff-hl

#+begin_src emacs-lisp
(use-package diff-hl
  :config
  (when (null vc-handled-backends)
    (message "%s" "global-diff-hl-mode cannot work. See documentation.")))
#+end_src

* iedit

#+begin_src emacs-lisp
(use-package iedit :demand
  :bind ("C-;" . iedit-mode))
#+end_src

* repeat

#+begin_src emacs-lisp
(use-package repeat :demand)
#+end_src

* imenu

#+begin_src emacs-lisp
(use-package imenu :demand
  :config
  (setq imenu-auto-rescan t))
#+end_src

* tab-bar

#+begin_src emacs-lisp
(use-package tab-bar :demand
  :config
  (tab-bar-mode))
#+end_src

* avy

#+begin_src emacs-lisp
(use-package avy :demand
  :bind
  ("C-:" . avy-goto-char))
#+end_src

* expand-region

#+begin_src emacs-lisp
(use-package expand-region :demand
  :bind
  ("C-<" . er/expand-region))
#+end_src

* magit

#+begin_src emacs-lisp
(use-package magit
  :config
  (defun transient-prefix-object ()
    (or transient--prefix transient-current-prefix))
  :bind
  (("C-x g" . magit-status)))
#+end_src

* paredit

#+begin_src emacs-lisp
(use-package paredit
  :hook
  (emacs-lisp-mode . paredit-mode)
  (scheme-mode . paredit-mode))
#+end_src

* rainbow-delimiters

#+begin_src emacs-lisp
(use-package rainbow-delimiters
  :hook (prog-mode . rainbow-delimiters-mode))
#+end_src

* geiser

#+begin_src emacs-lisp
(use-package geiser
  :config
  (setq geiser-active-implementations '(guile))
  :hook
  (scheme-mode . turn-on-geiser-mode))

(use-package geiser-guile :demand
  :config
  (add-to-list 'geiser-guile-load-path "~/src/guix"))

(use-package macrostep :demand)

(use-package macrostep-geiser :demand
  :after geiser-mode
  :config (add-hook 'geiser-mode-hook #'macrostep-geiser-setup))

(use-package macrostep-geiser :demand
  :after geiser-repl
  :config (add-hook 'geiser-repl-mode-hook #'macrostep-geiser-setup))
#+end_src

* rg

#+begin_src emacs-lisp
(use-package rg :demand
  :config
  (rg-enable-default-bindings)
  (setq rg-command-line-flags '()))
#+end_src

* vertico

#+begin_src emacs-lisp
(use-package vertico :demand
  :config
  (vertico-mode)
  (setq vertico-scroll-margin 0)
  (setq vertico-count 20)
  (setq vertico-resize t)
  (setq vertico-cycle t))
#+end_src

* consult

#+begin_src emacs-lisp
(use-package consult :demand
  :bind
  (("C-s" . consult-line)
   ("C-r" . consult-ripgrep)
   ("C-c f" . consult-find)
   ("M-." . xref-find-definitions)
   ("M-i" . consult-imenu)
   ("C-x b" . consult-buffer)
   ("C--" . consult-mark)
   ("C-y" . consult-yank-replace)
   ("C-z" . consult-recent-file)
   ("M-g g" . consult-goto-line))
  :hook
  (completion-list-mode . consult-preview-at-point-mode)
  :config
  (advice-add #'register-preview :override #'consult-register-window)
  (setq xref-show-xrefs-function #'consult-xref
        xref-show-definitions-function #'consult-xref))
#+end_src

* orderless

#+begin_src emacs-lisp
(use-package orderless :demand
  :custom
  (completion-styles '(orderless basic))
  (completion-category-overrides '((file (styles basic partial-completion)))))
#+end_src

* marginalia

#+begin_src emacs-lisp
(use-package marginalia :demand
  :bind (:map minibuffer-local-map
         ("M-A" . marginalia-cycle))

  :config
  (marginalia-mode))
#+end_src

* yasnippet

#+begin_src emacs-lisp
(use-package yasnippet :demand
  :init
  (require 'f)
  :config
  (setq yas--default-user-snippets-dir nil)
  (add-to-list 'yas-snippet-dirs (f-join user-emacs-directory "snippets"))
  (setq yas-new-snippet-default
        "# -*- mode: snippet -*-
# name: $1
# key: ${2:${1:$(yas--key-from-desc yas-text)}}
# expand-env: ((yas-indent-line 'fixed) (yas-wrap-around-region 'nil))
# --
$0`(yas-escape-text yas-selected-text)`")
  (yas-global-mode))
#+end_src

* corfu

#+begin_src emacs-lisp
(use-package corfu :demand
  :config
  (setq corfu-cycle t)
  (setq corfu-auto t)
  (setq corfu-separator ?\s)
  (setq corfu-scroll-margin 5)
  (global-corfu-mode))
#+end_src

* savehist

#+begin_src emacs-lisp
(use-package savehist :demand
  :config
  (savehist-mode))
#+end_src

* multiple-cursors

#+begin_src emacs-lisp
(use-package multiple-cursors :demand
  :bind (("M-m" . mc/edit-lines)))
#+end_src

* olivetti

#+begin_src emacs-lisp
(use-package olivetti :demand
  :config
  (setq olivetti-body-width 100))
#+end_src

* css

#+begin_src emacs-lisp
(use-package css-ts-mode
  :mode "\\.css\\'"
  :init
  (add-to-list 'major-mode-remap-alist '(css-mode . css-ts-mode)))
#+end_src

* epa-file

#+begin_src emacs-lisp
(use-package epa-file
  :config
  (epa-file-enable)
  (setq epa-file-name-regexp "\\.\\(gpg\\|asc\\)$")
  (epa-file-name-regexp-update)

  :hook
  ((find-file . user--protect-secret-files)
   (after-save . user--protect-secret-files)))

(defun user--protect-secret-files ()
  "Make files with .gpg or .asc extensions read-only when opened or saved."
  (when-let ((file-path (buffer-file-name)))
    (when (string-match-p ".*\\.\\(?:asc\\|gpg\\)$" file-path)
      (read-only-mode 1))))
#+end_src

* JavaScript

#+begin_src emacs-lisp
(use-package js
  :mode ("\\.js\\'" . js-ts-mode))
#+end_src

* JSON

#+begin_src emacs-lisp
(use-package json
  :mode ("\\.json\\'" . json-ts-mode))
#+end_src

* web-mode

#+begin_src emacs-lisp
(use-package web-mode
  :mode ("\\.html?\\'" . web-mode)
  :config
  (setq web-mode-indent-style 1)
  (setq web-mode-markup-indent-offset 2)
  (setq web-mode-css-indent-offset 2)
  (setq web-mode-code-indent-offset 2))
#+end_src

* sh-script

#+begin_src emacs-lisp
(use-package sh-mode
  :mode "\\.bash\\'"
  :init
  (add-to-list 'major-mode-remap-alist '(sh-mode . bash-ts-mode))
  (let* ((bash-ls-cmd "bash-language-server")
         (exit-status (call-process bash-ls-cmd nil nil nil "--version")))
    (unless (= exit-status 0)
      (message "WARNING: %s not found; bash language server functionality might
be limited." bash-ls-cmd)))
  :config
  (setq sh-basic-offset 2
        sh-indentation 2)
  :hook
  (bash-ts-mode . eglot-ensure))
#+end_src

* elixir

#+begin_src emacs-lisp
(use-package elixir-mode
  :mode (("\\.ex\\'" . elixir-mode)
         ("\\.exs\\'" . elixir-mode))
  :init
  (add-to-list 'major-mode-remap-alist '(elixir-mode . elixir-ts-mode)))

(use-package elixir-ts-mode
  :preface
  (unless (treesit-language-available-p 'elixir)
    (elixir-ts-install-grammar))
  :config
  (autoload 'elixir-ts-mode "elixir-ts-mode" "Major mode for Elixir" t))

(use-package heex-ts-mode
  :mode "\\.heex\\'"
  :preface
  (unless (treesit-language-available-p 'heex)
    (heex-ts-install-grammar)))
#+end_src

* pyvenv

#+begin_src emacs-lisp
(use-package pyvenv)
#+end_src

* flycheck

#+begin_src emacs-lisp
(use-package flycheck
  :config
  (flycheck-package-setup))
#+end_src

* locs-and-refs

#+begin_src emacs-lisp
(use-package locs-and-refs :demand
  :config
  (load-theme 'modus-vivendi t)
  (modus-themes-with-colors
     (custom-set-faces
      `(locs-and-refs-location-face
        ((t (:foreground ,magenta-faint :underline t))))
      `(locs-and-refs-reference-face
        ((t (:foreground ,red-faint :underline t))))))
  (locs-and-refs-mode))
#+end_src

* org-tidy

#+begin_src emacs-lisp
(use-package org-tidy)
#+end_src

* org-patches
:PROPERTIES:
:header-args:emacs-lisp+: :tangle elisp/org-patches.el
:END:

** Property drawers are removed after tangling

#+begin_src emacs-lisp
(defun user--org-remove-property-drawers ()
  "After tangling, remove all :PROPERTIES: drawers."
  (save-excursion
    (let ((inhibit-modification-hooks t)
          (modified-p (buffer-modified-p)))
      (goto-char (point-min))
      (while (re-search-forward ".*:PROPERTIES:$" nil t)
        (let ((start (line-beginning-position)))
          (when (re-search-forward ".*:END:\n" nil t)
            (delete-region start (point)))))
      (set-buffer-modified-p modified-p))))
(add-hook 'org-babel-post-tangle-hook #'user--org-remove-property-drawers)
#+end_src

** org-babel-spec-to-string is fixed
Like the original version
but do not insert useless new line.

#+begin_src emacs-lisp
(defun org-babel-spec-to-string (spec)
  "Insert SPEC into the current file.

Insert the source-code specified by SPEC into the current source
code file.  This function uses `comment-region' which assumes
that the appropriate major-mode is set.  SPEC has the form:

  (start-line file link source-name params body comment)"
  (pcase-let*
      ((`(,start ,file ,link ,source ,info ,body ,comment) spec)
       (comments (cdr (assq :comments info)))
       (link? (or (string= comments "both") (string= comments "link")
                  (string= comments "yes") (string= comments "noweb")))
       (link-data `(("start-line" . ,(number-to-string start))
                    ("file" . ,file)
                    ("link" . ,link)
                    ("source-name" . ,source)))
       (insert-comment (lambda (text)
                         (when (and comments
                                    (not (string= comments "no"))
                                    (org-string-nw-p text))
                           (if org-babel-tangle-uncomment-comments
                               ;; Plain comments: no processing.
                               (insert text)
                             ;; Ensure comments are made to be comments.  Also ignore
                             ;; invisible characters when commenting.
                             (comment-region
                              (point)
                              (progn (insert (org-no-properties text))
                                     (point))))))))
    (when comment (funcall insert-comment comment))
    (when link?
      (funcall insert-comment
               (org-fill-template
                org-babel-tangle-comment-format-beg link-data)))
    (insert body "\n")
    (when link?
      (funcall insert-comment
               (org-fill-template
                org-babel-tangle-comment-format-end link-data)))))
#+end_src

** Try to format all JS code blocks
- λ()
  - point :≡ point-min()
  - search-next-code-block() ≡
    - error[msg] ⇒ message(msg)
    - nil ⇒ ■
    - pair[start end] ⇒
      - format-code extract-code(start end) ≡
        - error[msg] ⇒ message(msg)
        - formatted-code ⇒ replace-code(start end formatted-code)
      - point :≡ end
      - λ()

#+begin_src emacs-lisp
(defun user-format-all-js-code-blocks ()
  "Format all JavaScript code blocks in the current buffer using Biomejs or Prettier.
If neither Prettier nor Biomejs is found in the PATH, signal an error.
Iteratively processes all blocks marked with the 'js' tag."
  (interactive)
  (save-excursion
    (goto-char (point-min))
    (pcase (user--next-code-block "js")
      ('nil
       (message "All JS code blocks have been formatted using %s" (user--format-code-cmd)))
      (`(:error ,msg)
       (user-error msg))
      (`(,start ,end)
       (pcase (user--format-code (user--extract-code start end)
                                 (get-buffer-create "*Formatting errors*"))
         (`(:error ,msg)
          (message "Code block starting at %s has not been formatted.\n%s" start msg)
          (with-restriction end (point-max)
            (user-format-all-js-code-blocks)))
         (formatted-code
          (user--replace-code start end formatted-code)
          (goto-char start)
          (pcase (user--next-code-block "js")
            (`(,start ,end)
             (with-restriction end (point-max)
               (user-format-all-js-code-blocks))))))))))

(defun user--next-code-block (tag)
  "Find the next code block tagged with TAG in the current buffer.
Returns nil if no block is found, or a list (START END) indicating
the region of the block, or an error if an unmatched block is found."
  (save-excursion
    (let ((case-fold-search t) begin-re end-re start)
      (setq begin-re
            (rx-to-string `(seq bol (0+ " ") "#+begin_src" (1+ " ") (literal ,tag) (not word))))
      (pcase (search-forward-regexp begin-re nil t)
        ('nil nil)
        (_
         (backward-char)
         (forward-line 1)
         (setq start (point))
         (setq end-re (rx-to-string '(seq bol (0+ " ") "#+end_src" (0+ " "))))
         (pcase (search-forward-regexp end-re nil t)
           ('nil
            (list :error (format "start of code block at %s has no matching end")))
           (_
            (beginning-of-line)
            (list start (point)))))))))

(defun user--extract-code (start end)
  "Extract the code between START and END in the current buffer.
Returns the content of the region as a string."
  (buffer-substring-no-properties start end))

(defun user--replace-code (start end code)
  "Replace the content between START and END with CODE in the current buffer."
  (save-excursion
    (kill-region start end)
    (goto-char start)
    (insert code)))

(defun user--format-code (code error-buffer)
  "Format the given CODE using Prettier.
If formatting succeeds, return the formatted code as a string.
If an error occurs, insert the error message into ERROR-BUFFER
and return an error indicator."
  (if (string= code "")
      ""
    (let (return-code)
    (with-temp-buffer
      (insert code)
      (setq return-code
            (shell-command-on-region
             (point-min)
             (point-max)
             (user--format-code-cmd)
             (current-buffer) t
             error-buffer))
      (pcase return-code
        (0
         (buffer-substring-no-properties (point-min) (point-max)))
        (_
         (list :error (format "Formatting error. See buffer %s" (buffer-name error-buffer)))))))))

(setq user--format-code-cmd-cache nil)
(defun user--format-code-cmd ()
  (if (null user--format-code-cmd-cache)
      (setq user--format-code-cmd-cache
            (pcase (executable-find "biome")
              ((and (pred stringp) path)
               (format "%s format --indent-style space --indent-width 4 --stdin-file-path tmp.js" path))
              (_
               (pcase (executable-find "prettier")
                 ((and (pred stringp) path)
                  (format "%s --stdin-filepath tmp.js" path))
                 (_
                  (user-error "neither biome nor prettier in the PATH"))))))
    user--format-code-cmd-cache))
#+end_src

** provide

#+begin_src emacs-lisp
(provide 'org-patches)
#+end_src

* org
:PROPERTIES:
:ID:       cc511d66-615b-4a92-8481-fb63ba23c43f
:END:

#+begin_src emacs-lisp
(use-package org
  :bind
  (("C-c C-l" . org-insert-link)
   ("M-RET" . org-insert-heading)
   ("M-<right>" . org-metaright))

  :config
  (add-to-list 'org-src-lang-modes '("js" . js-ts))
  (setq org-ellipsis " ")
  (setq org-hide-leading-stars t)
  (setq org-startup-indented t)
  (setq org-src-preserve-indentation t)
  (setq org-hide-emphasis-markers t)
  (setq org-todo-keywords
        '((sequence "TODO(t)" "WAITING(w)" "|" "DONE(d)" "FAILED(f)" "CANCELED(c)")))
  (setq org-todo-keyword-faces
        '(("TODO" . (:foreground "red" :family "JetBrains Mono" :height 0.9))
          ("WAITING" . (:foreground "orange" :family "JetBrains Mono" :height 0.9))
          ("FAILED" . (:foreground "purple" :family "JetBrains Mono" :height 0.9))
          ("DONE" . (:foreground "green" :family "JetBrains Mono" :height 0.9))
          ("CANCELED" . (:foreground "grey" :family "JetBrains Mono" :height 0.9))))
  (setq org-log-into-drawer t)
  (setq org-clock-into-drawer t)
  (org-babel-do-load-languages
   'org-babel-load-languages
   '((emacs-lisp . t)
     (C . t)
     (css . t)
     (shell . t)
     (lisp . t)
     (scheme . t)
     (dot . t)
     (awk . t)
     (R . t)
     (python . t)
     (js . t)))
  (setq org-src-fontify-natively t)
  (setq org-id-link-to-org-use-id t)
  (setq org-link-keep-stored-after-insertion t)

  (defun org-for-all-headings-add-id ()
    "Generate ID for any headings that are missing one"
    (interactive)
    (org-map-entries
     (lambda ()
       (let ((ID (org-entry-get (point) "ID")))
         (when (null ID)
           (org-entry-put (point) "ID" (org-id-new)))))))

  (require 'org-patches))
#+end_src

* org-agenda
:PROPERTIES:
:ID:       13586139-b0d3-406c-a3bc-e683ccc194e9
:END:

#+begin_src emacs-lisp
(use-package org-agenda :demand
  :bind (("C-c a" . org-agenda))

  :config
  (setq org-agenda-skip-scheduled-if-done nil
        org-agenda-span 'day
        org-agenda-show-future-repeats 'next
        org-columns-default-format-for-agenda "%SCHEDULED %CATEGORY %TODO %ITEM %Effort(Effort){:}"
        org-deadline-warning-days 1
        org-agenda-sorting-strategy '(time-up todo-state-down priority-down)
        org-agenda-prefix-format
        '((agenda . " %-12t %-18:c %s")
          (todo . " %i %-12:c")
          (tags . " %i %-12:c")
          (search . " %i %-12:c"))
        org-agenda-time-grid
        '((daily today require-timed)
          (600 2400)
          " ┄┄┄┄┄ " "┄┄┄┄┄┄┄┄┄┄┄┄┄┄┄"))

  (defun user--set-org-agenda-files (&rest _rest)
    "Dynamically set org-agenda-files based on TODO keywords in .org files."
    (let* ((keywords (with-temp-buffer
                       (org-mode)
                       (concat "(" (mapconcat #'identity org-todo-keywords-1 "|") ")")))
           (command (format "rg -u -m 1 -l -g '*.%s' '^\\*+ +%s' ~" "%s" keywords))
           (files (s-split "\n" (s-trim (shell-command-to-string (format command "org"))))))
      (setq org-agenda-files (seq-filter #'user--set-org-agenda-files-filters files))
      (message (string-join org-agenda-files "\n"))))

  (defun user--set-org-agenda-files-filters (file)
    (not (or (string-match-p ".*worg.*" file)
             (string-match-p ".*/dl-python-extracteur/tests/.*" file)
             (string-match-p ".*/dl-python-docparser/tests/.*" file))))

  (advice-add #'org-agenda :before #'user--set-org-agenda-files))
#+end_src

* local extension

#+begin_src emacs-lisp
(defun extend-init-locally ()
  (let* ((env-var "EMACS_INIT_EXTENSION")
         (local-conf (getenv env-var)))
    (if (and local-conf (file-exists-p local-conf))
        (load-file local-conf)
      (message "INFO: no local extension to default init.el has been found.
Set %s to a local elisp file to run it after init.el"
               env-var))))
(extend-init-locally)
#+end_src

* Local Variables  :noexport:
# Local Variables:
# org-confirm-babel-evaluate: nil
# fill-column: 85
# End:
