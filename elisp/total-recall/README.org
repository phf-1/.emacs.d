#+PROPERTY: header-args :noweb yes :mkdirp yes

* Objective
:PROPERTIES:
:ID:       2b6a2d42-bfd0-4658-b25a-b1b7000d1b01
:END:

#+name: commentary
#+begin_src emacs-lisp
This package provides `total-recall'.

`M-x total-recall' searches for Org files in the directory
specified by `trl-root-dir' that contain exercises. It lists the
exercises and presents a user interface to display them. For
each exercise, it shows the question first, followed by the
answer. It then records the user's performance, i.e., whether
they provided a correct answer. This data is stored in an SQLite
database at `trl-database', which is used to determine whether
the exercise should be reviewed sooner or later.

An exercise is any heading in an Org file such that:
- It has a property `TYPE' which value is `trl-type-id'.
- It has a property `ID' which value is a UUID.
- It has two sub-headings.
  - the first one encodes a question,
  - and the second on encodes an answer.
- Its parent file lives under `trl-root-dir'.
- example:

,* Name
:PROPERTIES: 
:TYPE: b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8
:ID: ced2b42b-bfba-4af5-913c-9d903ac78433
:END:

,** Question

<content>

,** Answer

<content>
#+end_src

* tangle-heading
:PROPERTIES:
:header-args+: :tangle tangle-heading :shebang "#!/usr/bin/env -S emacs --script"
:END:

- ~./tangle-heading file.org file.el directory~
  - Give ~file.org~
  - tangles the heading named ~file.el~ into ~./file.el~
  - moves the resulting file under ~directory~

#+begin_src emacs-lisp
(require 'org)
(require 'ob-core)

(setq org-id-track-globally nil)

;; Set Scheme implementation to Guile
(require 'ob-scheme)
(setq-default geiser-scheme-implementation 'guile)

(setq make-backup-files nil)
(setq auto-save-default nil)

(defun user--org-remove-property-drawers ()
  "After tangling, remove all :PROPERTIES: drawers."
  (save-excursion
    (goto-char (point-min))
    (while (re-search-forward "^.*:PROPERTIES:$" nil t)
      (let ((start (line-beginning-position)))
        (when (re-search-forward "^.*:END:\n" nil t)
          (delete-region start (point)))))
    (when (buffer-modified-p)
      (save-buffer))))
(add-hook 'org-babel-post-tangle-hook #'user--org-remove-property-drawers)

(defun org-babel-spec-to-string (spec)
  "Insert SPEC into the current file.

Insert the source-code specified by SPEC into the current source
code file.  This function uses `comment-region' which assumes
that the appropriate major-mode is set.  SPEC has the form:

  (start-line file link source-name params body comment)"
  (pcase-let*
      ((`(,start ,file ,link ,source ,info ,body ,comment) spec)
       (comments (cdr (assq :comments info)))
       (link? (or (string= comments "both") (string= comments "link")
                  (string= comments "yes") (string= comments "noweb")))
       (link-data `(("start-line" . ,(number-to-string start))
                    ("file" . ,file)
                    ("link" . ,link)
                    ("source-name" . ,source)))
       (insert-comment (lambda (text)
                         (when (and comments
                                    (not (string= comments "no"))
                                    (org-string-nw-p text))
                           (if org-babel-tangle-uncomment-comments
                               ;; Plain comments: no processing.
                               (insert text)
                             ;; Ensure comments are made to be comments.  Also ignore
                             ;; invisible characters when commenting.
                             (comment-region
                              (point)
                              (progn (insert (org-no-properties text))
                                     (point))))))))
    (when comment (funcall insert-comment comment))
    (when link?
      (funcall insert-comment
               (org-fill-template
                org-babel-tangle-comment-format-beg link-data)))
    (insert body "\n")
    (when link?
      (funcall insert-comment
               (org-fill-template
                org-babel-tangle-comment-format-end link-data)))))

(defun tangle-headline-to-dest (name dest)
  (let (pos)
    (when (not (file-directory-p dest)) (error "Destination directory `%s' does not exist." dest))
    (org-with-wide-buffer
     (save-excursion
       (setq pos (org-find-exact-headline-in-buffer name (current-buffer) t))
       (when (null pos) (error "Heading named `%s' not found." name))
       (goto-char pos)
       (org-narrow-to-subtree)
       (org-babel-tangle)
       (when (not (file-exists-p name)) (error "Tangling `%s' did not build matching file." name))
       (rename-file name (concat (file-name-as-directory dest) name) t)))))

;; Silence messages.
(fset 'message (lambda (&rest args) nil))

(let ((org-file (pop argv))
      (heading-name (pop argv))
      (dest-dir (pop argv)))
  (with-current-buffer (find-file-noselect org-file)
    (tangle-headline-to-dest heading-name dest-dir)))
#+end_src

* packages.scm
:PROPERTIES:
:header-args+: :tangle packages.scm
:END:

- List of Guix packages.

** locale

- Guix package that provides utf8 locale.

#+name: locale
#+begin_src scheme
(use-modules (gnu packages base))
(define locale
  (make-glibc-utf8-locales
   glibc
   #:locales (list "en_US")
   #:name "glibc-en-utf8-locales"))
#+end_src

** elisp-packages

- List of Elisp guix packages.

#+name: elisp-packages
#+begin_src scheme
(use-modules (gnu packages emacs-xyz))
(define elisp-packages (list emacs-package-lint))
#+end_src

** binaries

- List of Guix packages that provides binaries.

#+name: binaries
#+begin_src scheme
(use-modules
 (gnu packages base)
 (gnu packages bash)
 (gnu packages emacs)
 (gnu packages rust-apps)
 (gnu packages certs)
 (gnu packages admin)
 (gnu packages build-tools))

(define binaries
  (list

   ;; build dependencies
   ;; bash-minimal
   bash
   coreutils
   gnu-make
   emacs
   sed
   nss-certs

   ;; runtime dependencies
   ripgrep
   fd))
#+end_src

** ■

#+begin_src scheme
`(,locale ,@elisp-packages ,@binaries)
#+end_src

* init.bash
:PROPERTIES:
:header-args+: :tangle init.bash
:END:

- File that contains Bash environment variable declarations.

#+begin_src bash
export LC_ALL=en_US.UTF-8
#+end_src

* total-recall.el
:PROPERTIES:
:header-args+: :tangle total-recall.el
:ID:       cdbad43e-8627-4918-9881-0340cab623b5
:END:

** Header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetitions for Emacs -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÖHRING
;; Author: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.1
;; Package-Requires: ((emacs "27.1"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<commentary>>
;;
;;; Code:
#+end_src

** Dependencies

#+begin_src emacs-lisp
(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'org)
(require 'time-date)
#+end_src

** Configuration

#+begin_src emacs-lisp
(defgroup total-recall nil
  "Customization options for Total Recall.
This mode provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "trl-")

(defcustom trl-database (file-name-concat user-emacs-directory "total-recall.sqlite3")
  "Path to the SQLite database for storing exercise data."
  :type 'string
  :group 'total-recall)

(defcustom trl-ripgrep-cmd "rg"
  "Name or path of the Ripgrep executable."
  :type 'string
  :group 'total-recall)

(defcustom trl-root-dir (expand-file-name "~")
  "Root directory where Ripgrep searches for Org files."
  :type 'string
  :group 'total-recall)

(defcustom trl-type-id "b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8"
  "Type ID for Org headings representing exercises."
  :type 'string
  :group 'total-recall)

(defcustom trl-window-width 160
  "Width of the Total Recall UI in characters."
  :type 'integer
  :group 'total-recall)

(defcustom trl-window-height 90
  "Height of the Total Recall UI in characters."
  :type 'integer
  :group 'total-recall)
#+end_src

** Utils

*** time-to-iso8601

#+begin_src emacs-lisp
(defun trl--time-to-iso8601 (time)
  "Convert TIME to an ISO 8601 formatted string.
TIME is a Lisp timestamp. Returns a string in the format YYYY-MM-DDTHH:MM:SSZ."
  (format-time-string "%Y-%m-%dT%H:%M:%SZ" (time-convert time 'list) t))
#+end_src

*** iso8601-to-time

#+begin_src emacs-lisp
(defun trl--iso8601-to-time (iso8601)
  "Convert ISO8601 string to a Lisp timestamp.
ISO8601 is a string in ISO 8601 format. Returns a Lisp timestamp."
  (parse-iso8601-time-string iso8601))
#+end_src

*** time-init

#+begin_src emacs-lisp
(defun trl--time-init ()
  "Return a Lisp timestamp for January 1, 1970, 00:00:00 UTC."
  (encode-time 0 0 0 1 1 1970 0))
#+end_src

** Search

#+begin_src emacs-lisp
(defun trl--search (dir ext type-id)
  "Search for files containing TYPE-ID with extension EXT in directory DIR.
DIR is a string path to the directory. EXT is a string file extension (e.g., \"org\").
TYPE-ID is a string identifier to search for. Returns a list of file paths."
  (let ((cmd (format "%s -g '*.%s' -i --no-heading -n --color=never '%s' %s"
                     trl-ripgrep-cmd ext type-id dir))
        matches)
    (with-temp-buffer
      (call-process-shell-command cmd nil `(,(current-buffer) nil) nil)
      (goto-char (point-min))
      (while (not (eobp))
        (let* ((line (buffer-substring-no-properties
                      (line-beginning-position) (line-end-position)))
               (match (split-string line ":")))
          (push (car match) matches))
        (forward-line 1))
      (delete-dups matches))))
#+end_src

** Measure

*** measure-mk

#+begin_src emacs-lisp
(defun trl--measure-mk (id time)
  "Create a measure structure with ID and TIME.
ID is a string identifier. TIME is a Lisp timestamp. Returns a measure structure."
  (list :measure id time))
#+end_src

*** measure-p

#+begin_src emacs-lisp
(defun trl--measure-p (measure)
  "Return t if MEASURE is a valid measure structure, else nil."
  (memq (car-safe measure) '(:measure :success :failure :skip)))
#+end_src

*** measure-id

#+begin_src emacs-lisp
(defun trl--measure-id (measure)
  "Return the ID of MEASURE.
MEASURE is a measure structure. Returns a string."
  (trl--measure-rcv measure :id))
#+end_src

*** measure-time

#+begin_src emacs-lisp
(defun trl--measure-time (measure)
  "Return the timestamp of MEASURE.
MEASURE is a measure structure. Returns a Lisp timestamp."
  (trl--measure-rcv measure :time))
#+end_src

*** measure-rcv

#+begin_src emacs-lisp
(defun trl--measure-rcv (measure msg)
  "Extract information from MEASURE based on MSG.
MEASURE is a measure structure. MSG is a symbol (:id or :time).
Returns the corresponding value."
  (pcase-let (((or `(:measure ,id ,time)
                   `(_ :measure ,id ,time))
               measure))
    (pcase msg
      (:id id)
      (:time time))))
#+end_src

*** Success
**** success-measure-mk

#+begin_src emacs-lisp
(defun trl--success-measure-mk (id time)
  "Create a success measure with ID and TIME.
ID is a string identifier. TIME is a Lisp timestamp. Returns a success measure."
  (cons :success (trl--measure-mk id time)))
#+end_src

**** success-measure-p

#+begin_src emacs-lisp
(defun trl--success-measure-p (measure)
  "Return t if MEASURE is a success measure, else nil."
  (eq (car-safe measure) :success))
#+end_src

*** Failure
**** failure-measure-mk

#+begin_src emacs-lisp
(defun trl--failure-measure-mk (id time)
  "Create a failure measure with ID and TIME.
ID is a string identifier. TIME is a Lisp timestamp. Returns a failure measure."
  (cons :failure (trl--measure-mk id time)))
#+end_src

**** failure-measure-p

#+begin_src emacs-lisp
(defun trl--failure-measure-p (measure)
  "Return t if MEASURE is a failure measure, else nil."
  (eq (car-safe measure) :failure))
#+end_src

*** Skip
**** skip-measure-mk

#+begin_src emacs-lisp
(defun trl--skip-measure-mk (id time)
  "Create a skip measure with ID and TIME.
ID is a string identifier. TIME is a Lisp timestamp. Returns a skip measure."
  (cons :skip (trl--measure-mk id time)))
#+end_src

**** skip-measure-p

#+begin_src emacs-lisp
(defun trl--skip-measure-p (measure)
  "Return t if MEASURE is a skip measure, else nil."
  (eq (car-safe measure) :skip))
#+end_src

** UI

*** ui-mk

#+begin_src emacs-lisp
(defun trl--ui-mk ()
  "Create a Total Recall UI.
Returns a UI structure containing a buffer and frame."
  (let ((frame (make-frame `((width . ,trl-window-width)
                             (height . ,trl-window-height))))
        (buffer (get-buffer-create "*total-recall*")))
    (list :ui buffer frame)))
#+end_src

*** ui-p

#+begin_src emacs-lisp
(defun trl--ui-p (ui)
  "Return t if UI is a valid UI structure, else nil."
  (eq (car-safe ui) :ui))
#+end_src

*** ui-no-exercises

#+begin_src emacs-lisp
(defun trl--ui-no-exercises (ui)
  "Display a 'no exercises' message in UI.
UI is a UI structure."
  (trl--ui-rcv ui :no-exercises))
#+end_src

*** ui-display-question

#+begin_src emacs-lisp
(defun trl--ui-display-question (ui exercise)
  "Display EXERCISE's question in UI.
UI is a UI structure. EXERCISE is an exercise structure."
  (trl--ui-rcv ui `(:display :question ,exercise)))
#+end_src

*** ui-display-answer

#+begin_src emacs-lisp
(defun trl--ui-display-answer (ui exercise)
  "Display EXERCISE's question and answer in UI.
UI is a UI structure. EXERCISE is an exercise structure."
  (trl--ui-rcv ui `(:display :answer ,exercise)))
#+end_src

*** ui-kill

#+begin_src emacs-lisp
(defun trl--ui-kill (ui)
  "Close UI by killing its buffer and frame.
UI is a UI structure."
  (trl--ui-rcv ui :kill))
#+end_src

*** ui-rcv

#+begin_src emacs-lisp
(defun trl--ui-rcv (ui msg)
  "Handle MSG for UI.
UI is a UI structure. MSG is a message like :no-exercises, (:display :question EXERCISE),
(:display :answer EXERCISE), or :kill. Signals an error if UI is invalid."
  (unless (trl--ui-p ui) (error "Not a UI structure"))
  (pcase-let ((`(:ui ,buffer ,frame) ui))
    (select-frame-set-input-focus frame)
    (switch-to-buffer buffer)
    (org-mode)
    (erase-buffer)
    (insert "* Total Recall *\n\n\n")
    (pcase msg
      (:no-exercises
       (save-window-excursion
         (insert "No exercises found.\n"))
       :noop)

      (`(:display :question ,ex)
       (let ((name (trl--exercise-name ex))
             (id (trl--exercise-id ex))
             (question (trl--exercise-question ex)))
         (insert (format "[[ref:%s][%s]]\n\n\n" id name))
         (insert (format "%s\n\n\n" question))
         (goto-char (point-min))))

      (`(:display :answer ,ex)
       (let ((name (trl--exercise-name ex))
             (id (trl--exercise-id ex))
             (question (trl--exercise-question ex))
             (answer (trl--exercise-answer ex)))
         (insert (format "[[ref:%s][%s]]\n\n\n" id name))
         (insert (format "%s\n\n\n" question))
         (insert (format "%s\n\n\n" answer))
         (goto-char (point-min))))

      (:kill
       (kill-buffer buffer)
       (delete-frame frame)
       :noop))))
#+end_src

** DB

*** db-mk

#+begin_src emacs-lisp
(defun trl--db-mk (path)
  "Open an SQLite database at PATH.
PATH is a string file path. Returns an SQLite database handle."
  (sqlite-open path))
#+end_src

*** db-p

#+begin_src emacs-lisp
(defun trl--db-p (x)
  "Return t if X is an SQLite database handle, else nil."
  (sqlitep x))
#+end_src

*** db-save

#+begin_src emacs-lisp
(defun trl--db-save (db measure)
  "Save MEASURE to database DB.
DB is an SQLite database handle. MEASURE is a measure structure. Returns t."
  (trl--db-rcv db `(:save ,measure)))
#+end_src

*** db-select

#+begin_src emacs-lisp
(defun trl--db-select (db id)
  "Retrieve measures for exercise ID from database DB.
DB is an SQLite database handle. ID is a string exercise identifier.
Returns a list of measure structures."
  (trl--db-rcv db `(:select :measures ,id)))
#+end_src

*** db-close

#+begin_src emacs-lisp
(defun trl--db-close (db)
  "Close database DB.
DB is an SQLite database handle. Returns t."
  (trl--db-rcv db :close))
#+end_src

*** db-rcv

#+begin_src emacs-lisp
(defun trl--db-rcv (db msg)
  "Handle MSG for SQLite database DB.
DB is an SQLite database handle. MSG can be (:save MEASURE), :close,
(:select :measures ID), (:measure-to-row MEASURE), or (:row-to-measure ROW).
Returns the result of the operation (e.g., t, list of measures)."
  (unless (sqlite-select db "SELECT name FROM sqlite_master WHERE type='table' AND name='exercise_log'")
    (sqlite-execute db
                    "CREATE TABLE exercise_log (
                       type TEXT NOT NULL,
                       id TEXT NOT NULL,
                       time TEXT NOT NULL)"))
  (pcase msg
    (`(:measure-to-row ,measure)
     (pcase measure
       ((pred trl--measure-p)
        (let ((type
               (cond
                ((trl--success-measure-p measure) "success")
                ((trl--failure-measure-p measure) "failure")))
              (id (trl--measure-id measure))
              (time (trl--time-to-iso8601 (trl--measure-time measure))))
          (list type id time)))
       (_ (error "measure is not a Measure. S%" measure))))

    (`(:row-to-measure ,row)
     (pcase row
       (`(,type ,id ,time)
        (pcase type
          ("success" (trl--success-measure-mk id (trl--iso8601-to-time time)))
          ("failure" (trl--failure-measure-mk id (trl--iso8601-to-time time)))))))

    (`(:save ,measure)
     (pcase measure
       ((pred trl--measure-p)
        (sqlite-execute
         db
         "INSERT INTO exercise_log (type, id, time) VALUES (?, ?, ?)"
         (trl--db-rcv db `(:measure-to-row ,measure)))
        t)
       (_ (error "Unexpected value: %S" measure))))

    (`(:select :measures ,id)
     (let (rows)
       (setq rows
             (sqlite-select
              db
              "SELECT type, id, time FROM exercise_log WHERE id = ? ORDER BY time ASC"
              (list id)))
       (mapcar
        (lambda (row) (trl--db-rcv db `(:row-to-measure ,row)))
        rows)))

    (:close
     (sqlite-close db)
     t)

    (_ (error "Unknown message: %S" msg))))
#+end_src

** Exercise

*** exercise-mk

#+begin_src emacs-lisp
(defun trl--exercise-mk (name id question answer)
  "Create an exercise with NAME, ID, QUESTION, and ANSWER.
NAME, ID, QUESTION, and ANSWER are strings. Signals an error if any argument
is not a string. Returns an exercise structure."
  (unless (stringp name) (error "Name is not a string"))
  (unless (stringp id) (error "ID is not a string"))
  (unless (stringp question) (error "Question is not a string"))
  (unless (stringp answer) (error "Answer is not a string"))
  (list :exercise name id question answer))
#+end_src

*** exercise-p

#+begin_src emacs-lisp
(defun trl--exercise-p (ex)
  "Return t if EX is an exercise structure, else nil."
  (eq (car-safe ex) :exercise))
#+end_src

*** exercise-name

#+begin_src emacs-lisp
(defun trl--exercise-name (exercise)
  "Return the name of EXERCISE.
EXERCISE is an exercise structure. Returns a string."
  (trl--exercise-rcv exercise :name))
#+end_src

*** exercise-id

#+begin_src emacs-lisp
(defun trl--exercise-id (exercise)
  "Return the ID of EXERCISE.
EXERCISE is an exercise structure. Returns a string."
  (trl--exercise-rcv exercise :id))
#+end_src

*** exercise-question

#+begin_src emacs-lisp
(defun trl--exercise-question (exercise)
  "Return the question of EXERCISE.
EXERCISE is an exercise structure. Returns a string."
  (trl--exercise-rcv exercise :question))
#+end_src

*** exercise-answer

#+begin_src emacs-lisp
(defun trl--exercise-answer (exercise)
  "Return the answer of EXERCISE.
EXERCISE is an exercise structure. Returns a string."
  (trl--exercise-rcv exercise :answer))
#+end_src

*** exercise-scheduled

#+begin_src emacs-lisp
(defun trl--exercise-scheduled (exercise db)
  "Return the scheduled review time for EXERCISE using database DB.
EXERCISE is an exercise structure. DB is an SQLite database handle.
Returns a Lisp timestamp."
  (trl--exercise-rcv exercise `(:scheduled ,db)))
#+end_src

*** exercise-rcv

#+begin_src emacs-lisp
(defun trl--exercise-rcv (exercise msg)
  "Handle MSG for EXERCISE.
EXERCISE is an exercise structure. MSG can be :name, :id, :question, :answer,
or (:scheduled DB). Returns the corresponding value (e.g., string or timestamp)."
  (pcase-let ((`(:exercise ,name ,id ,question ,answer) exercise))
    (pcase msg
      (:name name)
      (:id id)
      (:question question)
      (:answer answer)
      (`(:scheduled ,db)
       (let (measures (last-failure-index -1) nbr last-success-time)
         (setq measures (trl--db-select db id))

         (let ((i -1))
           (dolist (measure measures)
             (setq i (+ i 1))
             (when (trl--failure-measure-p measure)
               (setq last-failure-index i))))

         (setq nbr
               (if (< last-failure-index 0)
                   (length measures)
                 (- (length measures) (1+ last-failure-index))))

         (setq last-success-time
               (when (> nbr 0)
                 (let ((last-measure (nth (1- (length measures)) measures)))
                   (if (trl--success-measure-p last-measure)
                       (trl--measure-time last-measure)
                     (error "Last measure is not a success despite NBR > 0")))))

         (if (zerop nbr)
             (trl--time-init)
           (let* ((delta-days (expt 2 (- nbr 1)))
                  (delta-secs (* delta-days 24 60 60))
                  (t-secs (time-to-seconds last-success-time))
                  (result-secs (+ t-secs delta-secs)))
             (seconds-to-time result-secs))))))))
#+end_src

** Filesystem

*** fs-list-exercises

#+begin_src emacs-lisp
(defun trl--fs-list-exercises (path)
  "List exercises in PATH.
PATH is a string file or directory path. Returns a list of exercise structures."
  (trl--fs-rcv path :list-exercises))
#+end_src

*** fs-rcv

#+begin_src emacs-lisp
(defun trl--fs-rcv (path msg)
  "Handle MSG for PATH.
PATH is a string file or directory path. MSG is a symbol like :list-exercises.
Delegates to directory or file handlers. Returns the handler’s result."
  (cond
   ((file-directory-p path)
    (trl--dir-rcv path msg))
   ((file-exists-p path)
    (trl--file-rcv path msg))))
#+end_src

*** Directory
**** dir-list-exercises

#+begin_src emacs-lisp
(defun trl--dir-list-exercises (dir)
  "List exercises in Org files under directory DIR.
DIR is a string directory path. Returns a list of exercise structures."
  (trl--dir-rcv dir :list-exercises))
#+end_src

**** dir-rcv

#+begin_src emacs-lisp
(defun trl--dir-rcv (dir msg)
  "Handle MSG for directory DIR.
DIR is a string directory path. MSG is a symbol like :list-exercises.
Returns a list of exercise structures for :list-exercises."
  (pcase msg
    (:list-exercises
     (mapcan
      (lambda (file-path) (trl--file-rcv file-path :list-exercises))
      (trl--search dir "org" trl-type-id)))))
#+end_src

*** File
**** file-list-exercises

#+begin_src emacs-lisp
(defun trl--file-list-exercises (file)
  "List exercises in Org file FILE.
FILE is a string file path. Returns a list of exercise structures."
  (trl--file-rcv file :list-exercises))
#+end_src

**** file-rcv

#+begin_src emacs-lisp
(defun trl--file-rcv (file msg)
  "Handle MSG for Org file FILE.
FILE is a string file path. MSG is a symbol like :list-exercises.
Returns a list of exercise structures for :list-exercises."
  (pcase msg
    (:list-exercises
     (with-temp-buffer
       (insert-file-contents file)
       (org-mode)
       (org-show-all)
       (let ((org-element-use-cache nil)
             (exercises '()))
         (org-map-entries
          (lambda ()
            (let ((id (org-entry-get nil "ID"))
                  (name (org-format-outline-path (org-get-outline-path t) 10000))
                  question answer)
              (save-restriction
                (org-narrow-to-subtree)
                (org-next-visible-heading 1)
                (unless (org-at-heading-p) (error "Question not found"))
                (save-restriction
                  (org-narrow-to-subtree)
                  (let ((init-lvl (org-current-level)))
                    (while (> (org-current-level) 1) (org-promote-subtree))
                    (org-mark-subtree)
                    (setq question
                          (string-trim
                           (buffer-substring-no-properties (point) (mark))))
                    (while (< (org-current-level) init-lvl) (org-demote-subtree))))
                (org-goto-sibling)
                (unless (org-at-heading-p) (error "Answer not found"))
                (save-restriction
                  (org-narrow-to-subtree)
                  (let ((init-lvl (org-current-level)))
                    (while (> (org-current-level) 1) (org-promote-subtree))
                    (org-mark-subtree)
                    (setq answer
                          (string-trim
                           (buffer-substring-no-properties (point) (mark))))
                    (while (< (org-current-level) init-lvl) (org-demote-subtree))))
                (push (trl--exercise-mk name id question answer) exercises))))
          (format "TYPE=\"%s\"" trl-type-id))
         (reverse exercises))))))
#+end_src

** total-recall

#+begin_src emacs-lisp
;;;###autoload
(defun total-recall ()
  "Provide spaced repetitions capabilities to Emacs.

<<commentary>>"
  (interactive)
  (let ((exercises (trl--fs-list-exercises trl-root-dir))
        (db (trl--db-mk trl-database))
        (now (current-time))
        (ui (trl--ui-mk))
        (use-dialog-box nil)
        exercise
        scheduled
        choice)
    (if (null exercises)
        (trl--ui-no-exercises ui)
      (while exercises
        (setq exercise (pop exercises))
        (setq scheduled (trl--exercise-scheduled exercise db))
        (when (time-less-p scheduled now)
          (trl--ui-display-question ui exercise)
          (setq choice
                (car
                 (read-multiple-choice
                  "What would you like to do?"
                  '((?r "Reveal answer" "Display the answer to the question")
                    (?s "Skip" "Skip this exercise")
                    (?q "Quit" "Quit Total Recall")))))
          (pcase choice
            (?r
             (trl--ui-display-answer ui exercise)
             (setq choice
                   (car
                    (read-multiple-choice
                     "What would you like to do?"
                     '((?s "Success" "You successfully answered the question")
                       (?f "Failure" "You failed to answer the question")
                       (?q "Quit" "Quit Total Recall")))))
             (pcase choice
               (?s
                (trl--db-save db (trl--success-measure-mk (trl--exercise-id exercise) now)))
               (?f
                (trl--db-save db (trl--failure-measure-mk (trl--exercise-id exercise) now)))
               (?q
                (setq exercises nil))))
            (?s
             nil)
            (?q
             (setq exercises nil))))))
    (trl--db-close db)
    (trl--ui-kill ui)))
#+end_src

** Footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
* Makefile
:PROPERTIES:
:header-args+: :tangle Makefile
:END:
** Configuration

- List of Makefile configurations.

#+begin_src makefile
SHELL := bash
.SHELLFLAGS := -ceuo pipefail
MAKEFLAGS += --no-print-directory
.ONESHELL:
.SILENT:
#+end_src

*** BUILD

- ${BUILD} is the directory under which all generated files are installed.

#+begin_src makefile
BUILD := _build
${BUILD}:
        mkdir -p $@
#+end_src

*** TRACE

- ${TRACE} is a file used to record an execution trace.

#+begin_src makefile
TRACE := ${BUILD}/trace.txt
#+end_src

*** TRAP

- ${TRAP} If something has been written to ${TRACE}, then consider that the rule failed.

#+begin_src makefile
TRAP := > ${TRACE}; trap 'if [[ $$? -ne 0 ]]; then cat ${TRACE}; fi' EXIT
#+end_src

*** MAIN_ORG

- ${MAIN_ORG} is the path to source file.

#+begin_src makefile
MAIN_ORG := README.org
#+end_src

** help

- make help # Print this help.

#+begin_src makefile
.PHONY: help
help:
        grep '^# - make ' $(MAKEFILE_LIST) | sed 's/^# - make //' | awk 'BEGIN {FS = " # "}; {printf "\033[36m%-30s\033[0m %s\n", $$1, $$2}'
#+end_src

** tangle-heading

- make tangle-heading # Returns the path to the updated ./tangle-heading script.

#+begin_src makefile
.PHONY: tangle-heading
TANGLE_HEADING := ${BUILD}/tangle-heading
tangle-heading: ${TANGLE_HEADING}
${TANGLE_HEADING}: ${MAIN_ORG} | ${BUILD}
        ${TRAP}
        ./tangle-heading ${MAIN_ORG} tangle-heading ${BUILD} &> ${TRACE}
        cp -vf ${BUILD}/tangle-heading ./tangle-heading &>> ${TRACE}
        tail -n 1 ${TRACE}
#+end_src

** Makefile

- make Makefile # Returns the path to the updated ./Makefile.

#+begin_src makefile
.PHONY: Makefile
MAKEFILE := ${BUILD}/Makefile
Makefile: ${MAKEFILE}
${MAKEFILE}: ${MAIN_ORG} | ${BUILD}
        ${TRAP}
        ./tangle-heading ${MAIN_ORG} Makefile ${BUILD} &> ${TRACE}
        cp -vf ${BUILD}/Makefile ./Makefile &>> ${TRACE}
        tail -n 1 ${TRACE}
#+end_src

** packages.scm

- make packages.scm # Returns the path to the Guix packages available in the environment.

#+begin_src makefile
.PHONY: packages.scm
PACKAGES_SCM := ${BUILD}/packages.scm
packages.scm: ${PACKAGES_SCM}
${PACKAGES_SCM}: ${MAIN_ORG} | ${BUILD}
        ${TRAP}
        ./tangle-heading ${MAIN_ORG} packages.scm ${BUILD} &> ${TRACE}
        echo "$@"
#+end_src

** init.bash

- make init.bash # Returns the path to parameters that initialize Bash in the environment.

#+begin_src makefile
.PHONY: init.bash
INIT_BASH := ${BUILD}/init.bash
init.bash: ${INIT_BASH}
${INIT_BASH}: ${MAIN_ORG} | ${BUILD}
        ${TRAP}
        ./tangle-heading ${MAIN_ORG} init.bash ${BUILD} &> ${TRACE}
        echo "$@"
#+end_src

** env

- make env # Starts the environment.

#+begin_src makefile
.PHONY: env
GUIX := guix
GUIX_SHELL := ${GUIX} shell --container \
        -F \
        -N \
        --file=${PACKAGES_SCM} \
        --preserve='^TERM$$' \
        -- bash --init-file ${INIT_BASH}
env: ${PACKAGES_SCM} ${INIT_BASH}
        CMD="${CMD}"
        if [[ ! -v GUIX_ENVIRONMENT ]]; then
          if [[ "$${CMD}" == "" ]]; then
            ${GUIX_SHELL} -i;
          else
            ${GUIX_SHELL} -c "${CMD}";
          fi
        else
          ${CMD}
          :
        fi
#+end_src

** el

- make el # Returns the path to the elisp package.

#+begin_src makefile
.PHONY: el
TOTAL_RECALL_EL := ${BUILD}/total-recall.el
el: ${TOTAL_RECALL_EL}
${TOTAL_RECALL_EL}: ${MAIN_ORG} | ${BUILD}
        ${TRAP}
        ./tangle-heading ${MAIN_ORG} total-recall.el ${BUILD} &> ${TRACE}
        # sed -i '1,2d' ${TOTAL_RECALL_EL} &>> ${TRACE}
        [[ -s ${TRACE} ]] && exit 1
        echo "$@"
#+end_src

** elc

- make elc # Returns the path to the compiled elisp package.

#+begin_src makefile
.PHONY: elc
TOTAL_RECALL_ELC := ${BUILD}/total-recall.elc
elc: ${TOTAL_RECALL_ELC}
${TOTAL_RECALL_ELC}: ${TOTAL_RECALL_EL}
        ${TRAP}
        emacs -Q --batch \
        --eval '(setq org-id-track-globally nil)' \
        --eval '(defun reb-target-binding (_sym) (error "pcre2el v1.11"))' \
        -f batch-byte-compile $< &> ${TRACE}
        [[ -s ${TRACE} ]] && exit 1
        echo "$@"
#+end_src

** lint

- make lint # Returns the path to the linting report of the elisp package.

#+begin_src makefile
.PHONY: lint
LINT_REPORT := ${BUILD}/lint-report.txt
lint: ${LINT_REPORT}
${LINT_REPORT}: ${TOTAL_RECALL_EL}
        ${TRAP}
        emacs --batch \
        --file $< \
        --eval '(setq org-id-track-globally nil)' \
        --eval "(progn (require 'package) (add-to-list 'package-archives '(\"melpa\" . \"https://melpa.org/packages/\") t) (package-initialize))" \
        --eval "(progn (require 'package-lint) (let ((errors (package-lint-buffer))) (when errors (message \"%s\" errors))))" &> ${TRACE}
        [[ -s ${TRACE} ]] && exit 1
        echo "$@"
#+end_src

** checkdoc

- make checkdoc # Returns the path to the analysis of the docstrings of the elisp package.

#+begin_src makefile
.PHONY: checkdoc
CHECKDOC := ${BUILD}/checkdoc.txt
checkdoc: ${CHECKDOC}
${CHECKDOC}: ${TOTAL_RECALL_EL}
        ${TRAP}
        emacs -Q --batch \
        --eval '(setq org-id-track-globally nil)' \
        --eval '(checkdoc-file "$<")' &> ${TRACE}
        [[ -s ${TRACE} ]] && exit 1
        echo "$@"
#+end_src

** test

- make test # Returns the path to the analysis of the docstrings of the elisp package.

#+begin_src makefile
.PHONY: test
TEST := ${BUILD}/test-log.txt
test: ${TEST}
${TEST}: ${TOTAL_RECALL_EL}
        ${TRAP}
        emacs -Q --batch \
        --eval '(setq org-id-track-globally nil)' \
        --eval '(load-file "$<")' \
        --eval '(ert-run-tests-batch-and-exit t)' &> $@
        echo "$@"
#+end_src

** all

- make all # Returns the path of the elisp package after lint, checkdoc and elc steps.

#+begin_src makefile
.PHONY: all
all: ${BUILD}
        ${TRAP}
        ${MAKE} env CMD="${MAKE} lint checkdoc elc" &> ${TRACE}
        echo ${TOTAL_RECALL_EL}
#+end_src

** clean

- make clean # Deletes all generated files.

#+begin_src makefile
.PHONY: clean
clean:
        rm -rfv ${BUILD}
#+end_src

* Message
** TODO Version the data saved by sqlite.
