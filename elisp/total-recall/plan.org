* Plan
** TODO Objective
:PROPERTIES:
:TYPE: a4f2ded2-4a69-4255-8460-c14096ccd9f9
:END:

*** Specification
:PROPERTIES:
:TYPE: e417e440-5951-41e8-8eab-a433b1985035
:END:

[[ref:2b6a2d42-bfd0-4658-b25a-b1b7000d1b01][Objective]]

*** Proof
:PROPERTIES:
:TYPE: ef106d98-a27a-488d-8184-8f671deaed15
:ID:       6bf8faa1-2ad8-4e6a-8fa9-e5cec3de9c2c
:END:

- Spec.
  - Spec is the language we are defining /i.e./ it is a set of expressions which
    meanings are mathematical in nature.

- Lang.
  - Lang refers to the target programming language. An expression of Spec may be
    associated with one in L.

- Proposition and proofs.
  - A proposition is an expression for which a proof may be provided. A "proof" is an expression

- Invariant.
  - Given a collection of objects, an "invariant" is a proposition that may be proven
    about all of these objects. A proof

- Type.
  - The expression "x : X" means that "x" satisfies the invariants represented by "X"
    /i.e./ "x" is a "X". "x" is an instance of the type "X".

- "d : Data" means that "d" refers to any kind of value in Lang.

- "x :â‰¡ y" means that "x" may be replaced by the expression "y" in any expression. We
  say that "x" is defined by "y".

- "x :â‰¡ Î»z.expression" means that "x" is defined by the lambda expression "Î»z.expression".

- "pair :â‰¡ <x y> : X Ã— Y" means that "pair" is a pair of two instances, the first one
  is "x" and second one is "y" and "x : X", "y : Y".

- "pair :â‰¡ <x y> : Î£(x:X),Y(x)" means that "pair" is a pair of two instances, the
  first one is "x" and second one is "y" and "x : X", "y : Y(x)". "x" may be
  implicit, we may write: "Î£X,Y".

- A "state" is defined as "<data tx>" where "data : Data" and "tx" is a function such that "tx(data) : Message â†’ Message Ã— State"

- "msg :â‰¡ Message#mk(name context objective) : Message" means that the result of executing the algorithm

- Actor#mk : State â†’ Actor :â‰¡ ðŸžŽ

- Given Î± :â‰¡ Actor#mk(state), then:
  - Î±#rcv(msg) :â‰¡
    1. <data tx> :â‰¡ state
    2. <reply state'> :â‰¡ tx(data) msg
    3. state :â‰¡ state'
    4. reply

- send : Actor Any â†’ Any :â‰¡ Î»Î±,msg.Î±#rcv(msg)

- Id :â‰¡ ðŸžŽ

- Context(Type â€¦) :â‰¡ Type Ã— â€¦

- Contract(name:Id t:Type Type â€¦) :â‰¡ name Ã— t Ã— Context(Type â€¦)

- Protocol#mk : Set(Contract) â†’ Protocol :â‰¡ ðŸžŽ

- Given p :â‰¡ Protocol#mk(set), then Î±:Actor satisfies p.
  - p :â‰¡
    - âˆ€ Contract(name t Type â€¦) âˆˆ set
    - âˆ€ context : Context(Type â€¦)
    - Î±#name(context) : t :â‰¡ send(Î± <name context>)

- Exercise#mk : Id Question Answer â†’ Exercise :â‰¡ ðŸžŽ

- Given e :â‰¡ Exercise#mk(id question answer), then e satisfies this protocol:
  - e#id = id
  - e#question = question
  - e#answer = answer

- DirectoryPath :â‰¡ ðŸžŽ

- root : DirectoryPath

- File#mk : String â†’ File :â‰¡ ðŸžŽ

- Given f :â‰¡ File#mk(path), then e satisfies this protocol:
  - f#path : String
  - f#ast : OrgAST

- Î± satisfies ExerciseFile :â‰¡
  - Î± contains an exercise âˆ¨ Î± contains a definition
  - Î±#exercises : List(Exercise)

- Searcher :â‰¡ Actors that satisfies this protocol:
  - Î±#search : List(ExerciseFile)

- ~M-x total-recall~ â†’ All exercises in root are reviewed.
  - total-recall#exec :â‰¡
    1. files :â‰¡ searcher#search : List(ExerciseFile)

    2. exercises :â‰¡ files#map(Î»file.file#exercises)
			 #sort(Î»x,y.x#card < y#card)
			 #flat

    3. scheduled_exercises :â‰¡ scheduler#filter(db exercises)

    4. ui#review(scheduled_exercises) :â‰¡
       - case exercises
	 - [] :â‰¡ self#stop
	 - [ exercise | rest ] :â‰¡
	   - case self#show(exercise)
	     - success : Success â†’
	       1. db#save(success)
	       2. self#review(rest)

	     - failure : Failure â†’
	       1. db#save(failure)
	       2. self#review(rest)

	     - skip : Skip â†’ self#review(rest)

	     - quit : Quit â†’ self#stop



- Î± satisfies Definition :â‰¡
  - Î±#type = "Definition"
  - Î±#id : String
  - Î±#content : String

- to_exercise : Definition â†’ Exercise :â‰¡
  1. Î± :â‰¡ Î» def
  2. Î±#type = "Exercise"
  3. Î±#id = def#id
  4. Î±#question = "Definition?"
  5. Î±#answer = def#content

- proover satisfies Ï€ :â‰¡
  - self#has_an_exercise(Î±) : Boolean
  - Î± contains an exercise :â‰¡ self#has_an_exercise(Î±) = true
  - self#has_a_definition(Î±) : Boolean
  - Î± contains a definition :â‰¡ self#has_an_definition(Î±) = true

- ExerciseFile :â‰¡ Path to a file that contains an exercise or a definition.
- List :â‰¡

- scheduler : Scheduler
- db : DB
- ui : UI

*** Verification
:PROPERTIES:
:TYPE: f90c64de-b391-43a6-8098-fa073e6298a6
:END:
