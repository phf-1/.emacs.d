# :ID: cdbad43e-8627-4918-9881-0340cab623b5
# :ID: 2b6a2d42-bfd0-4658-b25a-b1b7000d1b01

#+PROPERTY: header-args:emacs-lisp :noweb yes :mkdirp yes :tangle total-recall.el

* objective

#+name: objective
#+begin_src org
TODO
#+end_src

* header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetition system -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÃ–HRING
;; Author: Pierre-Henry FRÃ–HRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÃ–HRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.10
;; Package-Requires: ((emacs "29.4"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<objective>>
;;
;;; Code:
#+end_src

* dependencies

#+begin_src emacs-lisp
;; Dependencies

(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'cl-generic)
(require 'org)
(require 'time-date)
(require 'parse-time)
(require 'org-element)
(require 'cl-lib)
#+end_src

* configuration

#+begin_src emacs-lisp
;; Configuration

(defgroup total-recall nil
  "Customization options for Total Recall.
This package provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "total-recall-")

(defcustom total-recall-ripgrep-cmd "rg"
  "Specifies the name or path of the Ripgrep executable.
This is a string used to locate the Ripgrep command for file searching."
  :type 'string
  :group 'total-recall)

(defcustom total-recall-io-buffer-name "*TotalRecall*"
  "Specifies the name of the Total Recall output buffer.
This is a string used for the buffer where reports are written."
  :type 'string
  :group 'total-recall)

(defcustom total-recall-def-type "f590edb9-5fa3-4a07-8f3d-f513950d5663"
  "Specifies the UUID for identifying definition headings in Org files.
This is a string used to mark headings as definitions in Total Recall."
  :type 'string
  :group 'total-recall)

(defcustom total-recall-ex-type "b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8"
  "Specifies the UUID for identifying exercise headings in Org files.
This is a string used to mark headings as exercises in Total Recall."
  :type 'string
  :group 'total-recall)

(defcustom total-recall-window-width 160
  "Specifies the width of the Total Recall UI frame in characters.
This is an integer defining the frame width for the UI."
  :type 'integer
  :group 'total-recall)

(defcustom total-recall-window-height 90
  "Specifies the height of the Total Recall UI frame in characters.
This is an integer defining the frame height for the UI."
  :type 'integer
  :group 'total-recall)

(defcustom total-recall-key-skip ?k
  "Specifies the key to skip an exercise in the Total Recall UI.
This is a character used to skip the current exercise."
  :type 'character
  :group 'total-recall)

(defcustom total-recall-key-quit ?q
  "Specifies the key to quit the Total Recall session.
This is a character used to exit the UI session."
  :type 'character
  :group 'total-recall)

(defcustom total-recall-key-success ?s
  "Specifies the key to mark an exercise as successful in the Total Recall UI.
This is a character used to record a successful review."
  :type 'character
  :group 'total-recall)

(defcustom total-recall-key-failure ?f
  "Specifies the key to mark an exercise as failed in the Total Recall UI.
This is a character used to record a failed review."
  :type 'character
  :group 'total-recall)

(defcustom total-recall-key-reveal ?r
  "Specifies the key to reveal the answer in the Total Recall UI.
This is a character used to show the exercise answer."
  :type 'character
  :group 'total-recall)
#+end_src

* Buffer
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 58e40ccb-95ad-4aca-81c4-7be40372c901
:END:

[[info:elisp#Buffers][elisp#Buffers]]

* OrgBuffer
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 3be131b5-2eb2-49f1-b2bc-2fd8cfb68dda
:END:

An OrgBuffer is a [[ref:58e40ccb-95ad-4aca-81c4-7be40372c901][Buffer]] that has [[help:org-mode]] activated.

* OrgAST
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 8be264dc-9c8e-42b8-b919-98f2afa97f91
:END:

An OrgAST /i.e./ an [[ref:6eae3f77-b4fd-4956-bb2b-de2b459b4fb3][AST]] ~['org-data â€¦]~ that represents the content of the [[id:3be131b5-2eb2-49f1-b2bc-2fd8cfb68dda][OrgBuffer]]
~buffer~.

* buffer->org-ast
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       666d8740-7b4c-4bd3-a03f-90760eee176b
:END:

~buffer->org-ast(buffer)~ is the [[ref:8be264dc-9c8e-42b8-b919-98f2afa97f91][OrgAST]] derived from the [[ref:3be131b5-2eb2-49f1-b2bc-2fd8cfb68dda][OrgBuffer]] ~buffer~.

#+begin_src emacs-lisp
(defun total-recall--buffer->org-ast (buffer)
  (with-current-buffer buffer
    (unless (derived-mode-p 'org-mode)
      (error "org-mode is not activated in the current buffer."))
    (org-element-parse-buffer)))
#+end_src

* org-knowledge-file->dag
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

~org-knowledge-file->dag(path)~ is a DAG([[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUID]]) derived from the [[ref:b0c11bed-8c87-4c9b-b699-5d1c2230d0ad][OrgKnowledgeFile]]
~file~. The set of nodes is the union of the set of [[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUIDs]] of the [[ref:b90e4015-0a31-477c-a3e4-a4b2c87a6fb9][Elements]] of the
matching [[ref:8be264dc-9c8e-42b8-b919-98f2afa97f91][OrgAST]]. The set of edges is formed by the union of hierarchical edges and
referencial edges.

Let a,b : [[ref:83056aa9-1b7a-4678-a29e-7389db7f885f][OrgDefinition]] | [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][OrgExercise]]. If ~a~ and ~b~ have the same level and ~b~
comes juste after ~a~, then ~<b a>~ is an edge of hierarchical edges. If the level of ~b~
is the level of ~a~ + 1, and ~b~ is the first child of ~a~, then ~<a b>~ is an edge of
hierarchical edges. If ~b~ content has a reference ~a~, then ~<b a>~ is an edge of
referancial edges.

** TODO
Given a OrgKnowledgeFile named ~file.org~, ~kg :â‰¡ ~ is


org-knowledge-file->dag : OrgKnowledgeFile â†’ DAG :â‰¡
1. file.org : [[ref:b0c11bed-8c87-4c9b-b699-5d1c2230d0ad][OrgKnowledgeFile]]
2. els : Set(ReviewElement) :â‰¡
   1. list-el : List([[ref:278f886b-8fa5-487d-91a7-e2e27b90ab3f][Definition]] | [[ref:1793e4fa-1c89-4b92-9e26-6ca1c4441067][Exercise]]) :â‰¡ Î» file.org
   2. match duplicates(map Î»e.e#id() list-el)
      - { } â†’ set(list-el)
      - _ â†’ âŠ¥
3. dag :â‰¡
   1. rels : Set(Id Ã— Id) :â‰¡
      1. rels-hierarchy :â‰¡
         1. rels :â‰¡ {}
         2. âˆ€a:Heading âˆˆ file.org
            1. âˆƒb:heading âˆˆ file.org
               1. âˆ§ level(b) = level(a)
               2. âˆ§ b comes just after a
               3. â†’ rels :â‰¡ rels âˆª { <b#id() a#id()> }
            2. âˆƒb:heading âˆˆ file.org
               1. âˆ§ level(b) = level(a) + 1
               2. âˆ§ b first child of a
               3. â†’ rels :â‰¡ rels âˆª { <a#id() b#id()> }
         3. rels
      2. rels-reference :â‰¡
         1. rels :â‰¡ {}
         2. âˆ€e âˆˆ els, âˆ€id âˆˆ e#refs(), rels :â‰¡ rels âˆª { <e#id() id> }
         3. rels
      3. rels-hierarchy âˆª rels-reference
   2. nodes :â‰¡ set(map(Î»e.e#id() els)) âˆª set(flatten(rels))
   3. g :â‰¡ Graph nodes rels
   4. g is a DAG ? g : âŠ¥
4. < : els els â†’ Boolean :â‰¡
   - Î»a,b.âˆƒpath(b#id() a#id()) âˆˆ dag
5. p : [[ref:1e7ac163-18a7-44cd-bba9-97ed8029f319][TotalStrictOrder(<)]] :â‰¡
   1. p1 : âˆ€(a,b:ids), a < b or a = b or a > b :â‰¡
      - a,b:ids
      - cond
        1. a = b â†’ â– 
        2. a â‰  b â†’ â– 
   2. p2 : [[ref:bc98f978-3347-4ad8-8520-9b9c38c5b932][Transitive(<)]] :â‰¡
      1. assume a < b âˆ§ b < c
      2. then there is a path from c to b and b to a
      3. then there is a path from c to a
      4. then a < c
      5. â– 
   3. p3 : [[ref:4c9aeebc-00fe-4bd3-8fa3-b61838260e57][Irreflexive(<)]]
      1. a < a
      2. then there is a path from a to a in dag
      3. then âŠ¥
      4. â– 
   4. â– 
6. â– 


#+begin_src emacs-lisp

#+end_src

* TODO dag->order
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 98acbc5a-3630-4297-b8af-3344c0909033
:END:

* utils
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

#+begin_src emacs-lisp
;; Utils

(defun total-recall--truncate-str (str)
  "Truncates STR to 25 characters, replacing newlines with spaces.
Returns the truncated string with an ellipsis if necessary."
  (truncate-string-to-width
   (replace-regexp-in-string "\n" " " (string-trim str))
   25
   0
   nil
   "â€¦"))

(defun total-recall--not-implemented-error ()
  "Signals an error indicating the function is not implemented.
Throws an error with the message \"NotImplemented\"."
  (error "NotImplemented"))

(defun total-recall--not-implemented-warning ()
  "Displays a warning indicating the function is not implemented.
Shows a message \"WARNING: NotImplemented\" in the echo area."
  (message "WARNING: NotImplemented"))

(defun total-recall--timestamp-leq (t1 t2)
  "Check if timestamp T1 is less than or equal to T2.
Returns t if T1 is less than or equal to T2, nil otherwise."
  (or (time-less-p t1 t2)
      (equal t1 t2)))

(defconst total-recall--day (* 24 60 60)
  "Number of seconds in a day.")

(defun total-recall--find-last-index (lst pred)
  "Find the last index in LST where PRED return non-nil.
LST is a list, and PRED is a function taking a list element.
Returns the index of the last matching element or nil if none."
  (let ((index -1)
        (last-index nil))
    (dolist (item lst)
      (setq index (1+ index))
      (when (funcall pred item)
        (setq last-index index)))
    last-index))

(defun total-recall--org-element-lineage-map (fun datum &optional types with-self first-match)
  "Apply FUN to each ancestor of DATUM, from closest to farthest.
DATUM is an Org element or object.
TYPES, if non-nil, is a list of symbols to restrict ancestors.
WITH-SELF, if non-nil, includes DATUM if it matches TYPES.
FIRST-MATCH, if non-nil, stops at the first non-nil result from FUN.
Returns a list of non-nil results in reverse order or the first match."
  (let ((lineage (if with-self
                     (cons datum (org-element-lineage datum))
                   (org-element-lineage datum)))
        results)
    (catch 'first-match
      (dolist (element lineage)
        (when (or (not types)
                  (memq (org-element-type element) types))
          (let ((result (funcall fun element)))
            (when result
              (if first-match
                  (throw 'first-match result)
                (push result results)))))))
    (if first-match
        nil  ; If we reach here with first-match, no match was found
      (nreverse results))))

(defun total-recall--proc-start (path &optional args name)
  (let* ((name (or name (file-name-base path)))
         (process
          (apply #'start-process
                 (concat name "-process")
                 (concat "*" name "-buffer*")
                 path
                 args)))
    (set-process-query-on-exit-flag process nil)
    process))

(defun total-recall--proc-send (proc data &optional timeout)
  (if (not (process-live-p proc))
      (error "Process is not alive")
    (let ((output "")
          (timeout (or timeout 1)))
      (set-process-filter
       proc
       (lambda (process line)
         (setq output (concat output line))))
      (process-send-string proc (concat data "\n"))
      (accept-process-output proc timeout)
      output)))

(defun total-recall--proc-stop (proc)
  (when (and proc (process-live-p proc))
    (kill-process proc)
    (let ((buffer (process-buffer proc)))
      (when (buffer-live-p buffer)
        (kill-buffer buffer)))))
#+end_src

#+begin_src emacs-lisp
(defun total-recall--print-org-structure ()
  (interactive)
  (let ((print-length nil))
    (pp-eval-expression
     '(with-current-buffer (current-buffer)
        (org-element-parse-buffer)))))
#+end_src

* send
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: eaae96be-a72b-424c-9165-8141f5944ba6
:END:

Let actor : [[ref:d1295024-a8aa-4dd7-a2a1-1ef4d64781db][Actor]] and msg : [[ref:17cf4de2-18d2-4e90-876e-a537a6ce0616][Message]], then send(actor msg) :â‰¡ actor(msg).


#+begin_src emacs-lisp
(defun total-recall--send (actor msg)
  (funcall actor msg))
#+end_src


- total-recall--msg actor :â‰¡ send actor :msg
- total-recall--msg actor â€¦ :â‰¡ send actor '(:msg â€¦)


#+begin_src emacs-lisp
(defmacro total-recall--message (name)
  "Define a message function for NAME to send to an actor.
NAME is a symbol used to create a function `total-recall--NAME'.
The function sends a message to an actor with optional arguments."
  `(defun ,(intern (concat "total-recall--" (symbol-name name))) (actor &rest args)
     (total-recall--send actor
                         (pcase args
                           ('() ,(intern (concat ":" (symbol-name name))))
                           (_ (cons ,(intern (concat ":" (symbol-name name))) args))))))

(total-recall--message add)
(total-recall--message ambiguous-p)
(total-recall--message answer)
(total-recall--message buffer)
(total-recall--message buffer-name)
(total-recall--message date)
(total-recall--message debug)
(total-recall--message file)
(total-recall--message files)
(total-recall--message id)
(total-recall--message impredicative-p)
(total-recall--message info)
(total-recall--message list-of-ambiguities)
(total-recall--message list-of-definition)
(total-recall--message minibuffer)
(total-recall--message now)
(total-recall--message parse)
(total-recall--message path)
(total-recall--message question)
(total-recall--message ratings)
(total-recall--message read)
(total-recall--message refs)
(total-recall--message save)
(total-recall--message select)
(total-recall--message self-references)
(total-recall--message show-exercise)
(total-recall--message show-report)
(total-recall--message start)
(total-recall--message stop)
(total-recall--message string)
(total-recall--message struct)
(total-recall--message tick)
(total-recall--message tick2)
(total-recall--message value)
#+end_src

* Clock
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       3ca40a21-019b-4bba-b18b-bcec7282b445
:END:

Given a natural number named ~time~, ~clock : Clock :â‰¡ Clock#mk time~ is a clock. It
means that ~clock#read()~ is its current time and ~t :â‰¡ clock#read();
clock#tick()#read() = t + 1~. ~clock#now()~ is a lisp timestamp representing the UTC
time at the call.


#+begin_src emacs-lisp
;; Clock

(defun total-recall--Clock-membrane (msg)
  "Process incoming MSG for the clock actor.
MSG is a symbol or list representing a clock command.
Returns a list of instructions to be executed."
  (memq msg '(:read :tick :tick2 :now)))


(defun total-recall--Clock-tx (state msg)
  "Handle transaction INST for the clock actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a symbol representing a clock instruction.
Updates MEMORY based on INST."
  (let ((self (gethash :self state))
        (time (gethash :time state)))
    (pcase msg
      (:read `(,state ,time))
      (:now `(,state ,(time-convert (current-time) 'list)))
      (:tick
       (puthash :time (+ time 1) state)
       `(,state ,self))
      (:tick2
       (total-recall--Clock-tx state :tick)
       (total-recall--Clock-tx state :tick)
       `(,state ,self)))))


(defun total-recall--Clock-init (time)
  "Initialize a clock actor with TIME.
TIME is a natural number representing the initial clock time.
Returns a state hash table for the clock actor."
  (let ((state (total-recall--Actor-state
                #'total-recall--Clock-membrane
                #'total-recall--Clock-tx)))
    (puthash :time time state)
    state))

(total-recall--Actor #'total-recall--Clock-init total-recall--Clock)
#+end_src


#+begin_src emacs-lisp :tangle "total-recall-test.el"
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Clock ()
  (let ((clock (total-recall--Clock 0)))
    (should (= (total-recall--read clock) 0))
    (should (= (total-recall--read (total-recall--tick clock)) 1))
    (should (= (total-recall--read (total-recall--tick2 clock)) 3))))
#+end_src

* Logger
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

~logger :â‰¡ Logger#mk()~. ~msg : Line~, ~logger#info(msg)~,  ~logger#debug(msg)~.


#+begin_src emacs-lisp
;; Logger

(defun total-recall--Logger-membrane (msg)
  ""
  (pcase msg
    ((or `(:info ,obj) `(:debug ,obj)) t)
    (_ nil)))

(defun total-recall--Logger-tx (state msg)
  ""
  (let ((self (gethash :self state))
        (io (gethash :io state)))
    (pcase msg
      (`(:info ,obj)
       (total-recall--Logger-tx state (list :print "info" obj))
       `(,state ,self))

      (`(:debug ,obj)
       (total-recall--Logger-tx state (list :print "debug" obj))
       `(,state ,self))

      (`(:line ,obj)
       `(,state ,(string-trim (string-join (string-split (format "%s" obj) "\n") " "))))

      (`(:print ,prefix ,obj)
       (pcase (total-recall--Logger-tx state (list :line obj))
         (`(,state ,line)
          (total-recall--minibuffer io (string-join (list prefix line) " | "))))
       `(,state ,self)))))

(defun total-recall--Logger-init (data)
  ""
  (let ((state (total-recall--Actor-state
                 #'total-recall--Logger-membrane
                 #'total-recall--Logger-tx)))
    (pcase data
      (`(,io)
       (puthash :io io state)
       state)
      (_ (error "Unexpected data. data = %s" data)))))

(total-recall--Actor #'total-recall--Logger-init total-recall--Logger)
#+end_src

* Exercise
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       1793e4fa-1c89-4b92-9e26-6ca1c4441067
:END:

~exercise :â‰¡ Exercise#mk id path question answer~ represents an [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][exercise]] in ELisp. ~exercise#id()~
is a UUID string. ~exercise#question()~, ~exercise#answer()~ are strings. ~exercise#path()~
is a string of the form ~A/B/â€¦/Z~ that locates the exercise relative to its context
/i.e./ The exercise is about ~Z~ which parent heading is ~â€¦~ up until ~A~. ~exercise#string()~
is a one line string representation of the exercise for debugging purposes.
~exercise#file()~ is the absolute path to the file it has been extracted from.


#+begin_src emacs-lisp
;; Exercise

(defun total-recall--Exercise-membrane (msg)
  "Process incoming MSG for the exercise actor.
MSG is a symbol like `file`, `id`, `path`, `question`, `answer`, or `string`.
Returns a list containing the corresponding instruction."
  (pcase msg
    ((or :file :id :path :question :answer :string) t)
    (_ nil)))

(defun total-recall--Exercise-tx (state msg)
  "Handle transaction INST for the exercise actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a symbol like `file`, `id`, `path`, `question`, `answer`, or `string`.
Updates MEMORY with the requested data."
  (let ((file (gethash :file state))
        (id (gethash :id state))
        (path (gethash :path state))
        (question (gethash :question state))
        (answer (gethash :answer state)))

    (pcase msg
      (:file `(,state ,file))
      (:id `(,state ,id))
      (:path `(,state ,path))
      (:question `(,state ,question))
      (:answer `(,state ,answer))
      (:string
       `(,state
         ,(string-join
           `("Exercise("
             ,id
             ,(format "%s" path)
             ,(total-recall--truncate-str question)
             ,(total-recall--truncate-str answer) ")")
           " "))))))

(defun total-recall--Exercise-init (data)
  "Initialize an exercise actor with DATA.
DATA is a list of (FILE ID PATH QUESTION ANSWER), where FILE is a path,
ID is a UUID string, PATH, QUESTION, and ANSWER are strings.
Returns a state hash table for the exercise actor."
  (let ((state (total-recall--Actor-state #'total-recall--Exercise-membrane #'total-recall--Exercise-tx)))
    (pcase data
      (`(,file ,id ,path ,question ,answer)
       (puthash :file file state)
       (puthash :id id state)
       (puthash :path path state)
       (puthash :question question state)
       (puthash :answer answer state)
       state)
      (_
       (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--Exercise-init total-recall--Exercise)
#+end_src

* Definition
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       278f886b-8fa5-487d-91a7-e2e27b90ab3f
:END:

~definition :â‰¡ Definition#mk id path content~ represents a [[ref:83056aa9-1b7a-4678-a29e-7389db7f885f][definition]] in ELisp.
~definition#id()~ is a UUID string that identifies the definition. ~def1 = def2 â‡”
def1#id() = def2#id()~. ~definition#content()~ is a string that represents the content
of the definition. ~definition#path()~ is a string of the form ~A/B/â€¦/Z~ that locates the
definition relative to its context /i.e./ the definition is about ~Z~ which parent
heading is ~â€¦~ up until ~A~. ~definition~ satisfies the ~Exercise~ protocol.
~definition#refs()~ is a list of UUID, each one identifies a definition mentioned in
~definition#content()~.


#+begin_src emacs-lisp
;; Definition

(defun total-recall--Definition-membrane (msg)
  "Process incoming MSG for the definition actor.
MSG is a symbol like `file`, `id`, `path`, `content`, `question`,
`answer`, or `string`.  Returns a list containing the corresponding
instruction."
  (pcase msg
    ((or :file :id :path :content :question :answer :string :refs) t)
    (_ nil)))

(defun total-recall--Definition-tx (state msg)
  "Handle transaction INST for the definition actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a symbol like `file`, `id`, `path`, `content`, `question`, or `string`.
Updates MEMORY with the requested data."
  (let ((file (gethash :file state))
        (id (gethash :id state))
        (path (gethash :path state))
        (content (gethash :content state)))

    (pcase msg
      (:file `(,state ,file))
      (:id `(,state ,id))
      (:path `(,state ,path))
      (:content `(,state ,content))
      (:question `(,state ,"* Definition?"))
      (:string `(,state
                 ,(string-join
                   `("Definition("
                     ,id
                     ,(format "%s" path)
                     ,(total-recall--truncate-str content)
                     ")")
                   " ")))
      ;; TODO
      (:refs `(,state ,'())))))

(defun total-recall--Definition-init (data)
  "Initialize a definition actor with DATA.
DATA is a list of (FILE ID PATH CONTENT), where FILE is a path,
ID is a UUID string, PATH and CONTENT are strings.
Returns a state hash table for the definition actor."
  (let ((state (total-recall--Actor-state
                 #'total-recall--Definition-membrane
                 #'total-recall--Definition-tx)))
    (pcase data
      (`(,file ,id ,path ,content)
       (puthash :file file state)
       (puthash :id id state)
       (puthash :path path state)
       (puthash :content content state)
       state)
      (_
       (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--Definition-init total-recall--Definition)
#+end_src

** TODO refs implemented

* ReviewElement
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 6082d5e5-2249-4da0-aff9-dbb09b0ee064
:END:

ReviewElement :â‰¡ [[ref:278f886b-8fa5-487d-91a7-e2e27b90ab3f][Definition]] | [[ref:1793e4fa-1c89-4b92-9e26-6ca1c4441067][Exercise]]

* Parser
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

~parser :â‰¡ Parser#mk def-id ex-id~ is a parser such that ~parser#parse file~ is a list of
[[ref:83056aa9-1b7a-4678-a29e-7389db7f885f][definitions]] and [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][exercises]] found in ~file~ content in a depth first order relative to
the tree of headings. ~file~ is a path to an Org Mode file. ~def-id~ and ~ex-id~ are
strings that identify headings that are considered to be definitions or exercises
/i.e./ the ~:TYPE:~ property has a value equal to one of these values.


#+begin_src emacs-lisp
;; Parser

(defun total-recall--Parser-membrane (msg)
  "Process incoming MSG for the parser actor.
MSG is a list like `(parse FILE)` where FILE is a file path.
Returns a list containing the parse instruction."
  (pcase msg
    (`(:parse ,_file) t)
    (_ nil)))

(defun total-recall--Parser-tx (state msg)
  "Handle transaction INST for the parser actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a list like `(parse FILE)` where FILE is a file path.
Updates MEMORY with the parsed elements."
  (pcase msg
    (`(:parse ,file)

     (list
      state
      (with-temp-buffer
        (insert-file-contents file)
        (org-mode)
        (org-fold-show-all)
        (let ((org-element-use-cache nil))
          (total-recall--node-depth-first
           (org-element-parse-buffer 'greater-element)
           (lambda (node) (total-recall--node-to-element file node)))))))))

(defun total-recall--node-depth-first (node func)
  "Traverse NODE depth-first and apply FUNC to each node.
NODE is an Org element, and FUNC is a function taking a node.
Returns a list of non-error results from FUNC."
  (let ((head
         (mapcan
          (lambda (node) (total-recall--node-depth-first node func))
          (org-element-contents node)))
        (last (funcall func node)))
    (pcase last
      (:err head)
      (_ (append head (list last))))))

(defun total-recall--node-to-element (file node)
  "Convert NODE to an exercise or definition element from FILE.
FILE is the path to the Org file, and NODE is an Org element.
Returns an exercise or definition actor, or `:err` if not applicable."
  (let ((exercise-result (total-recall--node-to-exercise file node)))
    (if (eq exercise-result :err)
        (total-recall--node-to-definition file node)
      exercise-result)))

(defun total-recall--node-to-exercise (file node)
  "Convert NODE to an exercise actor from FILE.
FILE is the path to the Org file, and NODE is an Org element.
Returns an exercise actor or `:err` if NODE is not an exercise."
  (let (should-be-exercise id list-headline question answer)

    (setq should-be-exercise
          (and (eq (org-element-type node) 'headline)
               (string= (org-element-property :TYPE node) total-recall-ex-type)))

    (if should-be-exercise
        (progn
          (setq id (org-element-property :ID node))
          (unless (stringp id) (error "Exercise has no ID property"))
          (setq list-headline
                (seq-filter
                 (lambda (child) (eq (org-element-type child) 'headline))
                 (org-element-contents node)))
          (pcase (length list-headline)
            (0 (error "Exercise has no question nor answer: id = %s" id))
            (1 (error "Exercise has no answer: id = %s" id))
            (_
             (setq question (total-recall--node-to-string (car list-headline)))
             (setq answer (total-recall--node-to-string (cadr list-headline)))))

          (total-recall--Exercise
           (list
            file
            id
            (total-recall--node-subject node)
            question
            answer)))
      :err)))

(defun total-recall--node-to-definition (file node)
  "Convert NODE to a definition actor from FILE.
FILE is the path to the Org file, and NODE is an Org element.
Returns a definition actor or `:err` if NODE is not a definition."
  (let (should-be-definition id subject content)

    (setq should-be-definition
          (and (eq (org-element-type node) 'headline)
               (string= (org-element-property :TYPE node) total-recall-def-type)))

    (if should-be-definition
        (progn
          (setq id (org-element-property :ID node))
          (setq subject (total-recall--node-subject node))
          (unless (stringp id) (error "Definition has no ID property: file = %s" file))
          (setq content (total-recall--node-to-string node))
          (total-recall--Definition
           (list
            file
            id
            subject
            content)))
      :err)))

(defun total-recall--node-to-string (node)
  "Convert NODE to a string with headline leveled to level 1.
NODE is an Org element.
Returns the trimmed string representation."
  (replace-regexp-in-string
   "\\`\\*+" "*"
   (string-trim
    (buffer-substring-no-properties
     (org-element-property :begin node)
     (org-element-property :end node)))))

(defun total-recall--node-subject (node)
  "Extract the subject of NODE as a list of strings.
NODE is an Org headline element.
Returns a list of strings like (list A B C), where C is NODEâ€™s title and A, B are ancestors."
  (reverse
   (total-recall--org-element-lineage-map
    (lambda (parent) (org-element-property :raw-value parent))
    node '(headline) t)))

(defun total-recall--Parser-init (data)
  "Initialize a parser actor with DATA.
DATA is a list of (DEF-ID EX-ID), where DEF-ID and EX-ID are strings
identifying definition and exercise headings.
Returns a state hash table for the parser actor."
  (let ((state (total-recall--Actor-state
                #'total-recall--Parser-membrane
                #'total-recall--Parser-tx)))
    (pcase data
      (`(,def-id ,ex-id)
       (puthash :def-id def-id state)
       (puthash :ex-id ex-id state)
       state)
      (_
       (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--Parser-init total-recall--Parser)
#+end_src

* TODO Gnosis
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

* TODO set-kermos-gnoseos->gnosis
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

set-kermos-gnoseos->gnosis : Set(DAG) â†’ Gnosis :â‰¡ ðŸžŽ

* TODO org-file->org-knowledge-file
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

org-file->org-knowledge-file : OrgFile â†’ OrgKnowledgeFile :â‰¡

* Network
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       0863bc67-a376-4d52-9f71-88416477339f
:END:

Let ~def1,def2,def3 : Definition~. If ~def2~ contains a reference to ~def1~, then we write
~def2 â†’ def1 : Reference({ def1 def2 })~. Let ~defs : { Definition }~, then we may build
~refs(defs) : { Reference(defs) }~, the set of references over ~defs~. We call
~graph(defs) : Graph(defs) :â‰¡ <defs, refs(defs)>~. If ~def3 â†’ def2~ and ~def2 â†’ def1~, then
we write ~def3 â†’+ def1 : Path(graph(defs)) :â‰¡ <def3 def2 def1>~ meaning that there is a
path from ~def3~ to ~def1~. If ~def â†’+ def~, then we say that ~def~ is self referential. Let
~g :â‰¡ graph(defs)~, then ~self-references(g)~ is the set of self referential definitions.
If ~self-references(g) â‰  âˆ…~, then we say that ~g~ is impredicative. If ~g~ is not
impredicative, then ~g#list-of-definition()~ is the list of definitions using
topological order since it is a directed graph.


- ~g :â‰¡ Graph(defs)~
  - ~g#self-references() : List(List(Definition))~
  - ~g#impredicative-p() : Boolean :â‰¡ g#self-references() â‰  '()~
  - ~g#list-of-definition() : List(Definition)~
  - ~g#list-of-ambiguities() : List(list(Definition))~ l is an ambiguity, d1,d2 âˆˆ l, d1#id() = d2#id()
  - ~g#ambiguous-p() : Boolean :â‰¡ ~g#list-of-ambiguities() â‰  '()~


#+begin_src emacs-lisp
;; Network

(require 'json)

(defun total-recall--Network-membrane (msg)
  (pcase msg
    ((or :self-references :impredicative-p :list-of-definition :list-of-ambiguities :ambiguous-p) t)
    (_ nil)))

(defun total-recall--Network-tx (state msg)
  ""
  (let ((self (gethash :self state))
        (logger (gethash :logger state))
        (defs (gethash :defs state))
        (process (gethash :process state)))
    (total-recall--debug logger (list "begin rcv" msg))
    (pcase msg
      (:self-references
       (let ((msg (json-encode '((type . "Loops"))))
             loops)
         (setq loops (alist-get 'loops (json-read-from-string (total-recall--proc-send process msg))))

         `(,state
           ,(mapcar
             (lambda (loop)
               (pcase (total-recall--Network-tx state `(:ids-to-defs ,loop))
                 (`(,state ,defs) defs)))
             loops))))

      (:impredicative-p
       (pcase (total-recall--Network-tx state :self-references)
         (`(,state ,self-refs)
          `(,state ,(not (equal self-refs []))))))

      (:list-of-definition
       (let ((msg (json-encode '((type . "Sort"))))
             reply)
         (setq reply (alist-get 'nodes (json-read-from-string (total-recall--proc-send process msg))))
         (total-recall--Network-tx state `(:ids-to-defs ,reply))))

      (:list-of-ambiguities
       `(,state ,'()))

      (:ambiguous-p
       (pcase (total-recall--Network-tx state :list-of-ambiguities)
         (`(,state ,ambiguities)
          `(,state ,(not (eq ambiguities '()))))))

      (`(:ids-to-defs ,ids)
       `(,state ,(mapcar (lambda (id) (gethash id defs)) ids))))))

(defun total-recall--Network-init (defs)
  ""
  (let* ((state (total-recall--Actor-state #'total-recall--Network-membrane #'total-recall--Network-tx))
         (io (total-recall--IO total-recall-io-buffer-name))
         (logger (total-recall--Logger (list io)))
         (parent-dir (directory-file-name (file-name-directory load-file-name)))
         (executable-path (file-name-concat parent-dir "network-server")))
    (total-recall--debug logger (list "begin" "init"))
    (pcase defs
      (_
       (puthash
        :defs
        (let ((hashtable (make-hash-table :test 'equal)))
          (dolist (def defs hashtable)
            (puthash (total-recall--id def) def hashtable)))
        state)
       (puthash :logger logger state)
       (puthash :process (total-recall--proc-start executable-path) state)
       (total-recall--proc-send (gethash :process state)
                                (json-encode `((type . "Graph")
                                               (nodes . ,(mapcar #'total-recall--id defs))
                                               (refs . ,(mapcan #'total-recall--refs defs)))))
       (total-recall--debug logger (list "end" "init"))
       state)
      (_ (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--Network-init total-recall--Network)
#+end_src

#+begin_src emacs-lisp :tangle "total-recall-test.el"
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Network ()
  (let* ((def1 (total-recall--Definition (list "/tmp/test-file.org" "1" "subject1" "content")))
         (def2 (total-recall--Definition (list "/tmp/test-file.org" "2" "subject2" "content")))
         (def3 (total-recall--Definition (list "/tmp/test-file.org" "3" "subject3" "content")))
         (defs (list def1 def2 def3))
         (net (total-recall--Network defs)))
    (should (eq (total-recall--self-references net) '()))
    (should (not (total-recall--impredicative-p net)))
    (should (eq (total-recall--list-of-definition net) defs))
    (should (eq (total-recall--list-of-ambiguities net) '()))
    (should (not (total-recall--ambiguous-p net)))))
#+end_src

** network-server
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

1. p : NetworkProcess :â‰¡ ./network-server
2. p#rcv '{ "type": "Hello" }' = '{"type": "World"}'
3. p#rcv '{ "type": "Stop" }' : p is stopped.
4. p#rcv '{ "type": "Graph", "nodes": nodes, "refs": refs }' = '{"type": "Ack"}'
   - nodes : List(String)
   - refs : List(String Ã— String)
5. p#rcv '{ "type": "Loops" }' = '{"type": "Loops", "loops": loops }'
   - loops : List(List(String))
6. p#rcv '{ "type": "Sort" }' = '{"type": "Sort", "nodes": nodes }'
   - nodes : List(String)


- echo string | p :â‰¡
  - rcv(string) : None :â‰¡
    1. msg    : Message :â‰¡ transducer#msg string
    2. reply  : Dict    :â‰¡ interpreter#rcv msg
    3. output : String  :â‰¡ transducer#str reply
    4. None   : None    :â‰¡ io#stdout output

#+begin_src python :tangle "network-server" :shebang "#!/usr/bin/env python3"
import os
from network_server import Logger, IO, Transducer, Interpreter, Error, Stop

def main():
    logger = Logger(log_level=os.environ["LOG_LEVEL"])
    io = IO()
    transducer = Transducer()
    interpreter = Interpreter(io, logger)

    for string in io.stdin():
        logger.debug(f'string = {string}')

        try:
            msg = transducer.msg(string)
        except Exception as e:
            msg = Error(f'Error err occurred trying to transduce string. err = {e}. string = {string}')

        logger.debug(f'msg = {msg}')

        try:
            reply = interpreter.rcv(msg)
        except Exception as e:
            reply = Error(f'Error err occurred trying to interpret msg. err = {e}. msg = {msg}')

        logger.debug(f'reply = {reply}')

        try:
            output = transducer.str(reply)
        except Exception as e:
            output = Error(f'Error err occurred trying to transduce reply. err = {e}. reply = {reply}')

        logger.debug(f'output = {output}')

        io.stdout(output)

    interpreter.rcv(Stop())

if __name__ == "__main__":
    main()
#+end_src

*** __init__.py
:PROPERTIES:
:header-args:python+: :tangle "__init__.py"
:END:

#+begin_src python
#+end_src

*** imports
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
import os
import sys
import json
import signal
import logging
import kuzu
from typing import Self
from dataclasses import dataclass, field
import networkx as nx
#+end_src

*** Utils
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
def flatten(input_tree):
    output_list = []
    stack = list(input_tree)
    stack.reverse()
    while stack:
        item = stack.pop()
        match item:
            case list() as lst:
                lst.reverse()
                stack.extend(lst)
            case _:
                output_list.append(item)

    return output_list
#+end_src

*** Message
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
@dataclass
class Message:
    type: str = "Message"

    def dict(self):
        return {"type": self.type}

@dataclass
class Hello(Message):
    type: str = "Hello"

@dataclass
class World(Message):
    type: str = "World"

@dataclass
class Ack(Message):
    type: str = "Ack"

@dataclass
class Stop(Message):
    type: str = "Stop"

@dataclass
class Error(Message):
    type: str = "Error"
    msg: str = ""

    def dict(self):
        d = super().dict()
        d["msg"] = self.msg
        return d

@dataclass
class Graph(Message):
    type: str = "Graph"
    nodes: list[str] = field(default_factory=list)
    refs: list[list[str]] = field(default_factory=list)

    def dict(self):
        d = super().dict()
        d["refs"] = self.refs
        d["nodes"] = self.nodes
        return d

@dataclass
class Loops(Message):
    type: str = "Loops"
    loops: list[list[str]] = field(default_factory=list)

    def dict(self):
        d = super().dict()
        d["loops"] = self.loops
        return d

@dataclass
class Sort(Message):
    type: str = "Sort"
    nodes: list[str] = field(default_factory=list)

    def dict(self):
        d = super().dict()
        d["nodes"] = self.nodes
        return d
#+end_src

*** Transducer
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
class Transducer:
    def msg(self, string: str) -> dict:
        data = json.loads(string)
        match data["type"]:
            case "Hello":
                return Hello()

            case "Stop":
                return Stop()

            case "Graph":
                return Graph(nodes=data["nodes"], refs=data["refs"])

            case "Loops":
                return Loops()

            case "Sort":
                return Sort()

            case _:
                raise AssertionError(f"Unexpected JSON object. json = {data}")

    def str(self, msg: Message) -> str:
        return json.dumps(msg.dict())
#+end_src

*** IO
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
class IO:
    def stdin(self):
        return sys.stdin

    def stdout(self, string):
        line = string.strip() + '\n'
        sys.stdout.buffer.write(bytes(line, 'utf-8', 'strict'))
        sys.stdout.flush()

    def close(self):
        sys.stdin.close()
        sys.stdout.close()
#+end_src

*** Logger
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
class Logger:
    def __init__(self,log_level="INFO") -> None:
        formatter = logging.Formatter('%(asctime)s | %(levelname)s | %(message)s')
        handler = logging.StreamHandler(sys.stderr)
        handler.setFormatter(formatter)
        self._logger = logging.getLogger('network_server')
        self._logger.setLevel(getattr(logging, log_level))
        self._logger.addHandler(handler)

    def debug(self, msg: str) -> None:
        self._logger.debug(msg)
#+end_src

*** DB
**** specification

- db : DB :â‰¡ DB()
- db#add : List(String) List(String Ã— String) â†’ DB
- db#sort() : List(String)
- db#loops() : List(List(String))

**** implementation
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

***** TODO loops is implemented

***** â– 

#+begin_src python
class DB:
    def __init__(self,_data={}) -> None:
        self._db = db = kuzu.Database(":memory:")
        self._con = con = kuzu.Connection(db)
        con.execute("CREATE NODE TABLE Node(id STRING, PRIMARY KEY(id))")
        con.execute("CREATE REL TABLE References(FROM Node TO Node)")

    def add(self, nodes: list[str] = [], refs: list[list] = []) -> Self:
        con = self._con
        if nodes:
            nodes_list = ", ".join(f"'{node}'" for node in nodes)
            con.execute(f"UNWIND [{nodes_list}] AS node CREATE (n:Node {{id: node}})")
        if refs:
            refs_list = ", ".join(f"['{ref[0]}', '{ref[1]}']" for ref in refs)
            con.execute(f"UNWIND [{refs_list}] AS rel MATCH (a:Node {{id: rel[1]}}), (b:Node {{id: rel[2]}}) CREATE (a)-[:References]->(b)")
        return self

    def sort(self) -> list[str]:
        con = self._con
        res = self._con.execute("""
        MATCH (n:Node)
        OPTIONAL MATCH (n) -[r:References]-> (m:Node)
        RETURN n, r;
        """)
        graph = res.get_as_networkx(directed=True)
        relabel_mapping = {node: node.replace('Node_', '') for node in graph.nodes()}
        nx.relabel_nodes(graph, relabel_mapping, copy=False)
        components = sorted(nx.weakly_connected_components(graph), key=len, reverse=False)
        subgraphs = map(lambda component: graph.subgraph(component), components)
        ids = flatten(map(lambda graph: list(reversed(list(nx.topological_sort(graph)))), subgraphs))
        return ids

    def loops(self) -> list[list[str]]:
        raise NotImplementedError()
        return []
#+end_src

**** test
:PROPERTIES:
:header-args:python+: :tangle "network_server_test.py"
:END:

#+begin_src python
import pytest
from .network_server import DB

class TestDB:
    def test_db(self):
        db = DB()
        db.add(nodes=["a","b","c", "d"],refs=[["a","b"], ["a","c"], ["b","c"]])
        assert db.sort() == ["d", "c", "b", "a"]
#+end_src

*** Interpreter
:PROPERTIES:
:header-args:python+: :tangle "network_server.py"
:END:

#+begin_src python
class Interpreter:
    def __init__(self, io: IO, logger: Logger) -> None:
        self._io = io
        self._logger = logger
        self._db = DB()

    def rcv(self, msg: Message) -> dict | None:
        logger = self._logger
        logger.debug(f'interpreter.rcv(msg) where msg = {msg}')
        match msg:
            case Hello():
                return World()

            case Stop():
                self._io.close()
                sys.exit(0)

            case Error():
                return msg

            case Graph(nodes=nodes,refs=refs):
                self._db.add(nodes=nodes,refs=refs)
                return Ack()

            case Loops():
                return Loops(loops=[])

            case Sort():
                return Sort(nodes=self._db.sort())

            case _:
                raise AssertionError(f"Unexpected msg. msg = {msg}.")
#+end_src

*** test
:PROPERTIES:
:header-args:bash+: :tangle "network-server-test" :shebang "#!/usr/bin/env bash"
:END:

#+begin_src bash
set -euo pipefail
IFS=$'\n\t'
SERVER_RCV=/tmp/network-server-rcv.fifo
SERVER_OUTPUT=/tmp/network-server-output.fifo
rm -f ${SERVER_RCV} ${SERVER_OUTPUT}
mkfifo ${SERVER_RCV} ${SERVER_OUTPUT}
./network-server < ${SERVER_RCV} > ${SERVER_OUTPUT} &
SERVER_PID=$!
exec 3> ${SERVER_RCV}
exec 4< ${SERVER_OUTPUT}
function cleanup () {
    rm -f ${SERVER_RCV} ${SERVER_OUTPUT}
    exec 3>&-;
    exec 4<&-;
}
trap 'cleanup' EXIT INT TERM
messages=(
    '{ "type": "Hello" }'
    '{ "type": "Graph", "nodes": ["a","b","c"], "refs": [["a","b"]] }'
    '{ "type": "Sort" }'
    '{ "type": "Loops" }'
)
for msg in "${messages[@]}"; do
    if ! kill -0 ${SERVER_PID} 2>/dev/null; then
        echo "Error: Server is dead (PID: ${SERVER_PID})" >&2
        exit 1
    fi
    echo "$msg" >&3
    if ! read -t 2 -r reply <&4; then
        echo "Error: Timeout waiting for reply to '$msg'" >&2
        kill -HUP ${SERVER_PID} 2>/dev/null
        exit 1
    fi
    echo "send $msg = $reply"
done
echo '{ "type": "Stop" }' >&3
#+end_src

* Planner
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

~planner :â‰¡ Planner#mk clock db~ is a planner. ~planner#select exercises~ is a list of
exercises selected from ~exercises~ to be reviewed at the time of the call given data
represented by the database ~db~. An exercise ~ex~ from ~exercises~ is selected if its
~cutoff~ date comes before ~today :â‰¡ clock#now()~ /i.e./ ~cutoff â‰¤ today~. Given the list of
ratings ~ratings :â‰¡ db#ratings ex#id()~, we define :


#+begin_example
cutoff :â‰¡
  match db#ratings ex#id()
    [] â†’ today
    ratings â†’
      - match ratings
          el+ success_1 â€¦ success_n â†’
            - Î”t :â‰¡ 2^(n-1) days
            - date(success_n) + Î”t
          _ â†’ today
#+end_example


#+begin_src emacs-lisp
;; Planner

(defun total-recall--Planner-membrane (msg)
  "Process incoming MSG for the planner actor.
MSG is a list like `(select EXERCISES)` where EXERCISES is a list.
Returns a list containing the select instruction."
  (pcase msg
    (`(:select ,_exercises) t)
    (_ nil)))

(defun total-recall--Planner-tx (state msg)
  "Handle transaction INST for the planner actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a list like `(select EXERCISES)` or `(is_scheduled EX)`.
Updates MEMORY with the filtered exercises or scheduling decision."
  (let ((db (gethash :db state))
        (clock (gethash :clock state)))
    (pcase msg
      (`(:select ,exercises)
       `(,state
         ,(seq-filter
           (lambda (ex)
             (pcase (total-recall--Planner-tx state `(:is_scheduled ,ex))
               (`(,state ,is_scheduled) is_scheduled)))
           exercises)))

      (`(:is_scheduled ,ex)
       (let (today ratings last-failure-idx successes delta_t last-rating cutoff decision)
         (setq today (total-recall--now clock))
         (setq ratings (total-recall--ratings db (total-recall--id ex)))
         (setq successes
               (pcase ratings
                 ('nil '())
                 (_
                  (setq last-failure-idx
                        (total-recall--find-last-index
                         ratings
                         (lambda (rating) (eq (total-recall--value rating) 'failure))))

                  (seq-filter (lambda (rating) (eq (total-recall--value rating) 'success))
                              (pcase last-failure-idx
                                ('nil ratings)
                                ((pred (eq (- (length ratings) 1)) '()))
                                (_ (nthcdr (+ last-failure-idx 1) ratings)))))))
         (setq cutoff
               (pcase successes
                 ('nil today)
                 (_
                  (setq delta_t (* (expt 2 (- (length successes) 1)) total-recall--day))
                  (setq last-rating (car (last successes)))
                  (time-add (total-recall--date last-rating) delta_t))))
         (setq decision (total-recall--timestamp-leq cutoff today))
         `(,state ,decision))))))

(defun total-recall--Planner-init (data)
  "Initialize a planner actor with DATA.
DATA is a list of (DB CLOCK), where DB is a database actor and
CLOCK is a clock actor.
Returns a state hash table for the planner actor."
  (let ((state (total-recall--Actor-state #'total-recall--Planner-membrane #'total-recall--Planner-tx)))
    (pcase data
      (`(,db ,clock)
       (puthash :db db state)
       (puthash :clock clock state)
       state)
      (_ (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--Planner-init total-recall--Planner)
#+end_src

* total-recall
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:END:

** informal

The objective of ~total-recall~ is to schedule reviewing content so that you always
study the most impactful content first /i.e./ the one that has that maximizes the
impact on your overall predicted recall score.

** formal

Define Ï† : Set(Exercise) Time â†’ List(Exercise) such that:
1. âˆ€(ex âˆˆ Ï†(exs t)),review(ex t) = :success â†’ predicted_score(exs t) = 1.
2. âˆ€k, the exercises in Ï†[0:k] are chosen from exs to maximize the impact on predicted_score(exs t).

*** Exercise

An Exercise ex is an object from which a question, an answer and an id may be deduced
from. In other words: ex#question(),ex#answer() : OrgContent and ex#id() : UUID.
ex#string() represents the content of the exercise as an Org formatted string.

**** OrgContent

An OrgContent is a Org formatted string.

**** UUID

A UUIDv4 formatted string.


*** Reference
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 885d0860-25fa-4697-b9f4-7f150a047872
:END:

Let ex1, ex2 : Exercise, a reference(ex1 ex2) is introduced by adding a ref Org link
in ex1#string() to ex2#id(), or making ex2 a direct sub-heading of ex1#string().

*** < : Exercise Exercise â†’ Prop
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: a28fd20f-ce68-4fc3-bc94-16d8d9cfb517
:END:

# What it means
Let g :â‰¡ ReferenceGraph#mk(exs), and ex1,ex2 âˆˆ exs, <(g ex1 ex2) means that there is
a path(ex2 ex1) in g.

# How to proove it
<(g ex1 ex2) :â‰¡ ðŸžŽ

**** ReferenceGraph
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: df9bdab5-6395-4b0b-89a4-bedd5c57c829
:END:

# What it is
ReferenceGraph#mk : Set(Exercise) â†’ ReferenceGraph :â‰¡ Î»exs.
1. refs : Set(Reference) the set of references deduced from exs with starts and ends
   in exs.
2. g :â‰¡ digraph(exs refs)
3. g is a DAG
4. g

*** < : ReachableComponent ReachableComponent â†’ Prop
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 10429f86-c3a5-49a0-9d6e-3ad9d5a29da8
:END:

# What it means
Let c1 and c2 be ReachableComponents of a digraph(v e) â‰¡: g, then <(g c1 c2) means that
there is a path(n2 n1) such that n2,n1 âˆˆ v.

# How to prove it
# â€¦

*** review

review : Exercise Time â†’ Result models a user trying to solve
an exercise. review(ex t) = :success means that the user judged that his answer was
satisfying /i.e./ close enough from ex#answer() according to him.

*** Result :â‰¡ :success | :failure | :skip
*** predicted_score

predicted_score : Set(Exercise) Time â†’ interval(0 1) is an estimation of score.
predicted_score :â‰¡ Î»exs,t.Î£(ex âˆˆ exs),predicted_score(ex t) / card(exs)

**** score

score : Set(Exercise) Time â†’ interval(0 1) :â‰¡ Î»exs,t.
1. number_of_success :â‰¡ card({ x | âˆ€(ex âˆˆ exs),x : review(ex t) = :success })
2. number_of_success / card(exs)

** candidate


3. Let ~tr : TotalRecall :â‰¡ TotalRecall#mk root db-path~ be an [[ref:d1295024-a8aa-4dd7-a2a1-1ef4d64781db][actor]].
4. Assume that over the next few days you use ~M-x total-recall~ build your reviewing
   sessions,
5. then ~total-recall~ will minimize the number of reviews while maximizing your
   retention score over the set of elements found in the file system.

After ~total-recall()~, the user has reviewed as many [[ref:b90e4015-0a31-477c-a3e4-a4b2c87a6fb9][Exercise]] as are available under a
directory of his choosing. The presented Exercise have been selected for the session
using an algorithm that minimizes reviews per Exercise while maximizing retention
rate.

~total-recall()~ starts a [[ref:1783fedc-7c77-4e5e-a73d-f4c93c4d5eb8][TotalRecall]] that builds an execution
[[ref:05a4ce8c-583a-43d2-9dde-af32164d1a97][report]]. An [[ref:2076d556-ee35-4db7-bd58-887bc5a1c254][IO]] subsystem is used to write the report to the user.


#+begin_src emacs-lisp
;; total-recall

;;;###autoload
(defun total-recall ()
  "Run the Total Recall spaced repetition application.
Initiates a TotalRecall actor, processes data, and displays the report."
  (interactive)
  (let* ((tr (total-recall--TotalRecall t))
         (report (total-recall--start tr))
         (io (total-recall--IO total-recall-io-buffer-name)))
    (total-recall--buffer io (total-recall--string report))
    (total-recall--minibuffer io (format "Total-recall execution finished. Report written to %s" (total-recall--buffer-name io)))))
#+end_src

**** predicted_score

predicted_score : Exercise Time â†’ interval(0 1)
predicted_score(ex t) is an estimation of the probability that review(ex t) = :success


*** Element
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: b90e4015-0a31-477c-a3e4-a4b2c87a6fb9
:END:

An Element is either an [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][OrgExercise]], [[ref:83056aa9-1b7a-4678-a29e-7389db7f885f][OrgDefinition]] or a [[ref:65946d4e-80da-4e2a-9db5-5b86db1f5989][Reference]].

**** Reference
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 65946d4e-80da-4e2a-9db5-5b86db1f5989
:END:

A Reference is an [[ref:6eae3f77-b4fd-4956-bb2b-de2b459b4fb3][AST]] ~ast~ of the form ~['link â€¦]~ and which ~:path~ property is a
string that starts with ~"ref:"~ followed by a [[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUID]]. Given an AST ast,
~reference-p(ast) = true~ iff ast is a reference.


#+begin_src emacs-lisp
(defun total-recall--reference-p (ast)
  ;; TODO
  nil)
#+end_src

***** AST
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 6eae3f77-b4fd-4956-bb2b-de2b459b4fb3
:END:

An AST is a synonym for an "element or object" as described in the documentation of
[[help:org-element-parse-buffer][org-element-parse-buffer]]. It is a list ~[â€¦]~.

***** UUID
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 9ed6dfab-89aa-4bfb-8bff-d7a357546f2f
:END:

A UUID is a string that satisfies the [[https://en.wikipedia.org/wiki/Universally_unique_identifier#Version_4_(random)][UUIDv4 format]]. Given a string s, ~uuid-p(s) =
true~ iff ~s~ is a UUID.


#+begin_src emacs-lisp
(defun total-recall--string-uuid-p (str)
  (and (stringp str)
       (string-match-p
        "^[0-9a-fA-F]\\{8\\}-[0-9a-fA-F]\\{4\\}-[0-9a-fA-F]\\{4\\}-[0-9a-fA-F]\\{4\\}-[0-9a-fA-F]\\{12\\}$"
        str)))
#+end_src

**** OrgExercise
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       a474c4de-9bd2-4c2b-8189-c91eb0ab9014
:END:

An OrgExercise is a [[ref:c5fbf85e-e846-4a44-b590-23aaebe2c40e][HeadingAST]] that has a ~TYPE~ property of value
~b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8~ and an ~ID~ propety that is a [[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUID]] and two sub
headings. Given a HeadingAST h, ~exercise-p(h) = true~ iff ~h~ is an OrgExercise.

#+begin_src emacs-lisp
(defun total-recall--org-exercise-p (heading-ast)
  ;; TODO
  nil)
#+end_src

***** HeadingAST
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: c5fbf85e-e846-4a44-b590-23aaebe2c40e
:END:

A HeadingAST is an [[ref:8be264dc-9c8e-42b8-b919-98f2afa97f91][AST]] ~['headline â€¦]~. It represents the parsed content of a
heading. Given an AST ~ast~, ~heading-p(ast) = true~ iff ~ast~ is a HeadingAST.


#+begin_src emacs-lisp
(defun total-recall--heading-p (ast)
  (eq (car ast) 'headline))
#+end_src

**** OrgDefinition
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       83056aa9-1b7a-4678-a29e-7389db7f885f
:END:

An OrgDefinition is a [[ref:c5fbf85e-e846-4a44-b590-23aaebe2c40e][HeadingAST]] that has a type property of value
~f590edb9-5fa3-4a07-8f3d-f513950d5663~ and an id propety that is a [[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUID]]. The content of
the definition extends up to the first sub-definition or [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][sub-exercise]] if any. Given a
HeadingAST h, ~definition-p(h) = true~ iff h is an OrgDefinition.


#+begin_src emacs-lisp
(defun total-recall--org-definition-p (heading)
  ;; TODO
  nil)
#+end_src

*** IO
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 2076d556-ee35-4db7-bd58-887bc5a1c254
:END:

~io :â‰¡ IO#mk name~ is an [[ref:d1295024-a8aa-4dd7-a2a1-1ef4d64781db][actor]] that represents input/outputs of the current program.
~io#buffer(s)~ writes the string ~s~ to an output buffer named ~name~. ~io#minibuffer(s)~
writes the string ~s~ to Emacs minibuffer.


#+begin_src emacs-lisp
;; IO

(defun total-recall--IO-membrane (msg)
  (pcase msg
    ((or :buffer-name `(:minibuffer ,_string) `(:buffer ,_string)) t)
    (_ nil)))

(defun total-recall--IO-tx (state msg)
  (let ((self (gethash :self state))
        (buffer (gethash :buffer state))
        (name (gethash :name state)))

    (pcase msg
      (`(:minibuffer ,string)
       (message "%s" (string-trim string))
       `(,state ,self))

      (`(:buffer ,string)
       (with-current-buffer buffer
         (erase-buffer)
         (insert (string-join (list string "\n"))))
       `(,state ,self))

      (:buffer-name  `(,state ,name)))))

(defun total-recall--IO-init (name)
  "Initialize an IO actor with NAME.
NAME is a string for the output buffer name.
Returns a state hash table for the IO actor."
  (let ((state (total-recall--Actor-state
                #'total-recall--IO-membrane
                #'total-recall--IO-tx)))
    (puthash :buffer (get-buffer-create name) state)
    (puthash :name (buffer-name (gethash :buffer state)) state)
    state))

(total-recall--Actor #'total-recall--IO-init total-recall--IO)
#+end_src

**** Actor
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       d1295024-a8aa-4dd7-a2a1-1ef4d64781db
:END:

An Actor is represented by a procedure that returns values given a [[ref:17cf4de2-18d2-4e90-876e-a537a6ce0616][message]]. Given
init : Any â†’ [[ref:81e52518-3370-4a36-a17b-853ce95af579][State]], ~actor :â‰¡ Actor#mk init~. Given a message msg, actor(msg) is the
reply computed by actor in response to msg. The behavior of the actor can be
described by:


Actor#mk : (Any â†’ State) â†’ Any â†’ Message â†’ Any :â‰¡
- Î»init,any.
  1. state :â‰¡ init any
  2. Î»msg:Message.
     1. tx :â‰¡ state[:tx]
     2. check :â‰¡ state[:check]
     3. <state' any'> :â‰¡ tx state check(msg)
     4. state :â‰¡ state'
     5. any'


#+begin_src emacs-lisp
;; Actor

(defun total-recall--Actor-state (membrane tx)
  (let ((state (make-hash-table :test 'eq)))
    (puthash :check
             (lambda (msg)
               (if (funcall membrane msg) msg
                 (error "Unexpected msg. msg = %s" msg)))
             state)
    (puthash :tx tx state)
    state))

(defmacro total-recall--Actor (init name)
  `(defun ,name (any)
     (let* ((state (funcall ,init any))
            (actor (lambda (msg)
                     (let ((check (gethash :check state))
                           (tx (gethash :tx state)))

                       (pcase (funcall tx state (funcall check msg))
                         (`(,state-next ,reply)
                          (setf state state-next)
                          reply)

                         (value
                          (error "Unexpected value. value = %s" value)))))))
       (puthash :type ,name state)
       (puthash :self actor state)
       actor)))
#+end_src

***** Message
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 17cf4de2-18d2-4e90-876e-a537a6ce0616
:END:

A Message is either a [[ref:32932469-5c3a-4dfd-a116-04ea003acdcf][Keyword]] or a list that starts with a Keyword.

****** Keyword
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 32932469-5c3a-4dfd-a116-04ea003acdcf
:END:

[[info:elisp#Constant Variables][elisp#Constant Variables]]

***** State
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 81e52518-3370-4a36-a17b-853ce95af579
:END:

A State is a [[ref:20fa16f1-2e93-47bd-994e-c371b7ed90b4][Hashtable]] with at least the given keys and values:

|--------+----------------------------|
| Key    | Type                       |
|--------+----------------------------|
| :check | check : Message â†’ Message  |
| :tx    | tx : State Any â†’ State Any |
| :self  | actor : Actor              |
|--------+----------------------------|


For some predicate pred, check(msg) â‰¡ msg if pred(msg) = true or raise an exception.
check is used to filter messages it accepts to process.

****** Hashtable
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 20fa16f1-2e93-47bd-994e-c371b7ed90b4
:END:

[[help:make-hash-table]]

*** DOING TotalRecall
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: 1783fedc-7c77-4e5e-a73d-f4c93c4d5eb8
:END:



~tr#init()~ is a state that contains a [[ref:7c752724-7e3d-4529-bf1b-06482ca53b3e][ui]], a [[ref:aee4f045-f225-4e4c-a145-0cb2baad2186][db]], a [[ref:05a4ce8c-583a-43d2-9dde-af32164d1a97][report]], and ~els~, the list of
elements to be presented to the user. To build ~els~, a [[ref:f1bbb813-e964-4687-994c-bda31c6ba27b][searcher]] is used to find all
[[ref:b0c11bed-8c87-4c9b-b699-5d1c2230d0ad][OrgKnowledgeFiles]] under [[ref:5709bbc0-e7e6-4eba-90c9-1840b010f3b2][total-recall-root-dir]]. For each file, a set of [[ref:7b449631-bbec-4cf2-ae86-247871af14fe][nodes]] and
[[ref:061bc1d1-d892-4bac-bc04-e21f3593646f][edges]] is built from its elements and added to a [[ref:6b1ab7c6-087a-4f2a-a317-cede19042a73][DAG]]. The DAG is used to derive a
logical [[ref:696661be-ee3a-4f4d-9bf8-9b79e9edd9a7][order]] over the elements. The ordered list of elements is then pruned by a
[[ref:b6e43048-cf5d-4540-aab4-6b282e78fbb2][selector]].

~tr#start()~ presents each element of ~els~ to the user using the ui and records its
rating in the db until there are no more elements to review or the user decides to end
the review session.

~tr#start()~ minimizes the review time per session because only elements with a low
probability of success are presented for review. The elements are presented in an order
that minimizes "context switches" from one element to another, thus minimizing the
"mental energy" needed to complete the session.


#+begin_src emacs-lisp
;; TotalRecall

(defun total-recall--TotalRecall-membrane (msg)
  (pcase msg
    (:start t)
    (_ nil)))

(defun total-recall--TotalRecall-tx (state msg)
  (let ((self (gethash :self state))
        (goal (gethash :goal state))
        (root (gethash :root state))
        (db-path (gethash :db-path state))
        (searcher (gethash :searcher state))
        (parser (gethash :parser state))
        (db (gethash :db state))
        (planner (gethash :planner state))
        (ui (gethash :ui state))
        (nbr-files (gethash :nbr-files state))
        (nbr-exercises (gethash :nbr-exercises state))
        (report (gethash :report state))
        (files (gethash :files state))
        (exercises (gethash :exercises state)))

    (pcase msg
      (:start
       (let ((report (puthash :report (total-recall--Report t) state))
             (nbr-files (puthash :nbr-files 0 state))
             (nbr-exercises (puthash :nbr-exercises 0 state))
             (goal (puthash :goal :continue state)))
         (total-recall--add report "TotalRecall started.")
         (total-recall--add report (format "Definitions and exercises under %s will be reviewed." root))
         (total-recall--add report (format "Review results will be saved in %s." db-path))
         (puthash :files (total-recall--files searcher) state)
         (total-recall--add report (format "%s files have been found." (length (gethash :files state))))
         (total-recall--TotalRecall-tx state :process-files)
         (total-recall--add report "# End of TotalRecall execution. Report:")
         (total-recall--add report (format "%s files have been reviewed." (gethash :nbr-files state)))
         (total-recall--add report (format "%s exercises have been reviewed." (gethash :nbr-exercises state)))
         (total-recall--TotalRecall-tx state :stop)
         `(,state ,report)))

      (:process-files
       (pcase `(,goal ,files)
         (`(:stop ,_) `(,state ,self))
         ('(:continue ()) `(,state ,self))
         (`(:continue (,file . ,files))
          (total-recall--TotalRecall-tx state `(:process-file ,file))
          (puthash :nbr-files (+ (gethash :nbr-files state) 1) state)
          (puthash :files files state)
          (total-recall--TotalRecall-tx state :process-files))))

      (`(:process-file ,file)
       (pcase goal
         (:stop `(,state ,self))
         (:continue
          (total-recall--add report (format "file = %s" file))
          (puthash :exercises (total-recall--select planner (total-recall--parse parser file)) state)
          (total-recall--add report (format "%s exercises have been planned to be reviewed." (length (gethash :exercises state))))
          (total-recall--TotalRecall-tx state :process-exercises))))

      (:process-exercises
       (pcase `(,goal ,exercises)
         (`(:stop ,_) `(,state ,self))
         (`(,_ ()) `(,state ,self))
         (`(:continue (,exercise . ,exercises))
          (total-recall--TotalRecall-tx state `(:process-exercise ,exercise))
          (puthash :nbr-exercises (+ (gethash :nbr-exercises state) 1) state)
          (puthash :exercises exercises state)
          (total-recall--TotalRecall-tx state :process-exercises))))

      (`(:process-exercise ,exercise)
       (pcase goal
         (:stop `(,state ,self))
         (:continue
          (pcase (total-recall--show-exercise ui exercise)
            (:stop
             (puthash :goal :stop state)
             `(,state ,self))
            (`(:rating ,rating)
             (total-recall--add report (format "exercise = %s %s" (total-recall--id exercise) (total-recall--path exercise)))
             (total-recall--save db rating)
             (puthash :goal :continue state)
             `(,state ,self))))))

      (:stop
       (total-recall--stop ui)
       (total-recall--stop db)
       `(,state ,self))

      (_ (error "Unexpected instruction: msg = %s" msg)))))

(defun total-recall--TotalRecall-init (_data)
  (let ((state (total-recall--Actor-state #'total-recall--TotalRecall-membrane #'total-recall--TotalRecall-tx)))
    (puthash :clock (total-recall--Clock t) state)

    (puthash :db-path total-recall-database state)
    (puthash :db (total-recall--DB (gethash :db-path state)) state)

    (puthash :root total-recall-root-dir state)
    (puthash :def-type total-recall-def-type state)
    (puthash :ex-type total-recall-ex-type state)
    (puthash :searcher (total-recall--Searcher (list (gethash :root state) (gethash :def-type state) (gethash :ex-type state))) state)

    (puthash :parser (total-recall--Parser (list (gethash :def-type state) (gethash :ex-type state))) state)

    (puthash :planner (total-recall--Planner (list (gethash :db state) (gethash :clock state))) state)

    ;; TODO
    ;; (puthash :network (total-recall--Network '()) state)

    (puthash :ui (total-recall--UI (list "*TotalRecall UI*" total-recall-window-width total-recall-window-height (gethash :clock state))) state)

    (puthash :nbr-files 0 state)

    (puthash :nbr-exercises 0 state)

    (puthash :files '() state)

    (puthash :exercises '() state)

    (puthash :goal :continue state)

    state))

(total-recall--Actor #'total-recall--TotalRecall-init total-recall--TotalRecall)
#+end_src

**** TODO Selector
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       b6e43048-cf5d-4540-aab4-6b282e78fbb2
:END:

Given a natural number named ~time~, ~selector : Selector :â‰¡ Selector#mk time~ is a selector. It
means that ~selector#read()~ is its current time and ~t :â‰¡ selector#read();
selector#tick()#read() = t + 1~. ~selector#now()~ is a lisp timestamp representing the UTC
time at the call.


#+begin_src emacs-lisp
;; Selector

(defun total-recall--Selector-membrane (msg)
  "Process incoming MSG for the selector actor.
MSG is a symbol or list representing a selector command.
Returns a list of instructions to be executed."
  (memq msg '(:read :tick :tick2 :now)))


(defun total-recall--Selector-tx (state msg)
  "Handle transaction INST for the selector actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a symbol representing a selector instruction.
Updates MEMORY based on INST."
  (let ((self (gethash :self state))
        (time (gethash :time state)))
    (pcase msg
      (:read `(,state ,time))
      (:now `(,state ,(time-convert (current-time) 'list)))
      (:tick
       (puthash :time (+ time 1) state)
       `(,state ,self))
      (:tick2
       (total-recall--Selector-tx state :tick)
       (total-recall--Selector-tx state :tick)
       `(,state ,self)))))


(defun total-recall--Selector-init (time)
  "Initialize a selector actor with TIME.
TIME is a natural number representing the initial selector time.
Returns a state hash table for the selector actor."
  (let ((state (total-recall--Actor-state
                #'total-recall--Selector-membrane
                #'total-recall--Selector-tx)))
    (puthash :time time state)
    state))

(total-recall--Actor #'total-recall--Selector-init total-recall--Selector)
#+end_src


#+begin_src emacs-lisp :tangle "total-recall-test.el"
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Selector ()
  (let ((selector (total-recall--Selector 0)))
    (should (= (total-recall--read selector) 0))
    (should (= (total-recall--read (total-recall--tick selector)) 1))
    (should (= (total-recall--read (total-recall--tick2 selector)) 3))))
#+end_src

**** total-recall-root-dir
:PROPERTIES:
:ID:       5709bbc0-e7e6-4eba-90c9-1840b010f3b2
:END:

#+begin_src emacs-lisp
(defcustom total-recall-root-dir (expand-file-name "~")
  "Specifies the root directory for Total Recall file searches.
This is a string representing the directory path where Org Mode files
are searched."
  :type 'string
  :group 'total-recall)
#+end_src

**** TODO Order
:PROPERTIES:
:ID:       696661be-ee3a-4f4d-9bf8-9b79e9edd9a7
:END:

**** UI
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       7c752724-7e3d-4529-bf1b-06482ca53b3e
:END:

Given a buffer name ~name~, ~width~ and ~height~ of the frame in numbers of characters and
a clock ~clock~, then ~ui :â‰¡ UI#mk name width height clock~ is the UI. ~ui#show-exercise
exercise~ shows the exercise ~exercise~ to the user and return either ~'stop~ or a rating.
~ui#show-report report~ shows the report ~report~ to the user and returns itself.


#+begin_src emacs-lisp
;; UI

(defun total-recall--UI-membrane (msg)
  "Process incoming MSG for the UI actor.
MSG is a list like `(show-exercise EXERCISE)`, `(show-report REPORT)`,
or `stop`.  Returns a list containing the corresponding instruction."
  (pcase msg
    ((or :stop `(:show-exercise ,_exercise) `(:show-report ,_report)) t)
    (_ nil)))

(defun total-recall--UI-tx (state msg)
  "Handle transaction INST for the UI actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a list or symbol for UI operations like `show-exercise` or `stop`.
Updates MEMORY with the result of the operation."
  (let ((self (gethash :self state))
        (clock (gethash :clock state))
        (frame (gethash :frame state))
        (buffer (gethash :buffer state))
        (reviewed-nbr (gethash :reviewed-nbr state)))

    (pcase msg
      (`(:show-exercise ,exercise)
       (total-recall--UI-tx state :show-frame)
       (total-recall--UI-tx state :clear)
       (total-recall--UI-tx state `(:meta ,exercise))
       (total-recall--UI-tx state `(:show-content ,(total-recall--question exercise)))
       (pcase (total-recall--UI-tx state `(:ask ((,total-recall-key-quit . "Quit")
                                                 (,total-recall-key-skip . "Skip")
                                                 (,total-recall-key-reveal . "Reveal"))))
         (`(,state1 ,key1)
          (pcase key1
            ((pred (equal total-recall-key-quit)) (total-recall--UI-tx state :stop))
            ((pred (equal total-recall-key-skip)) (total-recall--UI-tx state `(:skip ,exercise)))
            ((pred (equal total-recall-key-reveal))
             (total-recall--UI-tx state `(:show-content ,(total-recall--answer exercise)))
             (puthash :reviewed-nbr (+ reviewed-nbr 1) state)
             (pcase (total-recall--UI-tx state `(:ask ((,total-recall-key-success . "Success")
                                                       (,total-recall-key-failure . "Failure")
                                                       (,total-recall-key-skip . "Skip")
                                                       (,total-recall-key-quit . "Quit"))))
               (`(,state2 ,key2)
                (pcase key2
                  ((pred (equal total-recall-key-success)) (total-recall--UI-tx state `(:success ,exercise)))
                  ((pred (equal total-recall-key-failure)) (total-recall--UI-tx state `(:failure ,exercise)))
                  ((pred (equal total-recall-key-skip)) (total-recall--UI-tx state `(:skip ,exercise)))
                  ((pred (equal total-recall-key-quit)) (total-recall--UI-tx state :stop))))))))))

      (:show-frame
       (select-frame-set-input-focus frame)
       (switch-to-buffer buffer)
       `(,state ,self))

      (:clear
       (with-current-buffer buffer
         (setq buffer-read-only nil)
         (erase-buffer)
         (unless (derived-mode-p 'org-mode) (org-mode))
         (insert "* Total Recall *\n\n")
         (goto-char (point-min))
         (setq buffer-read-only t))
       `(,state ,self))

      (`(:meta ,exercise)
       (let (meta)
         (setq meta (format "â”Œâ”€â”€â”€â”€
â”‚ path: %s
â”‚ link: %s
â”‚ reviewed: %s exercises
â””â”€â”€â”€â”€
"
                            (string-trim
                             (string-join
                              (append (string-split (total-recall--file exercise) "/")
                                      (total-recall--path exercise))
                              " / "))
                            (format "[[ref:%s]]" (total-recall--id exercise))
                            reviewed-nbr))
         (total-recall--UI-tx state `(:show-content ,meta)))
       `(,state ,self))

      (`(:show-report ,report)
       (total-recall--UI-tx state :clear)
       (total-recall--UI-tx state :show-frame)
       (total-recall--UI-tx state `(:show-content ,(total-recall--string report)))
       `(,state ,self))

      (`(:show-content ,content)
       (total-recall--UI-tx state :show-frame)
       (with-current-buffer buffer
         (setq buffer-read-only nil)
         (save-excursion
           (goto-char (point-max))
           (insert (string-join (list (string-trim content) "\n\n"))))
         (setq buffer-read-only t))
       `(,state ,self))

      (:stop
       (when (buffer-live-p buffer) (kill-buffer buffer))
       (when (frame-live-p frame) (delete-frame frame))
       `(,state :stop))

      (`(:ask ,options)
       (total-recall--UI-tx state :show-frame)
       (let (strs str key)
         (setq strs
               (mapcar
                (lambda (opt)
                  (pcase opt
                    (`(,char . ,name)
                     (format "%s (%s)" name (string char)))
                    (_
                     (error "Unexpected option: option = %s" opt))))
                options))
         (setq str (string-join strs ", "))
         (setq key (read-char-choice str (mapcar #'car options)))
         `(,state ,key)))

      (`(:skip ,exercise)
       `(,state
         ,`(:rating
            ,(total-recall--Rating
              (list (total-recall--now clock)
                    (total-recall--id exercise)
                    'skip)))))

      (`(:success ,exercise)
       `(,state
         ,`(:rating
            ,(total-recall--Rating
              (list (total-recall--now clock)
                    (total-recall--id exercise)
                    'success)))))

      (`(:failure ,exercise)
       `(,state
         ,`(:rating
            ,(total-recall--Rating
              (list (total-recall--now clock)
                    (total-recall--id exercise)
                    'failure))))))))

(defun total-recall--UI-init (data)
  "Initialize a UI actor with DATA.
DATA is a list of (NAME WIDTH HEIGHT CLOCK), where NAME is a buffer name,
WIDTH and HEIGHT are integers, and CLOCK is a clock actor.
Returns a state hash table for the UI actor."
  (let ((state (total-recall--Actor-state #'total-recall--UI-membrane #'total-recall--UI-tx)))
    (pcase data
      (`(,name ,width ,height ,clock)
       (puthash :buffer (get-buffer-create name) state)
       (with-current-buffer (gethash :buffer state) (setq buffer-read-only t))
       (puthash :name (buffer-name (gethash :buffer state)) state)
       (puthash :width width state)
       (puthash :height height state)
       (puthash :frame (make-frame `((width . ,width) (height . ,height))) state)
       (puthash :clock clock state)
       (puthash :reviewed-nbr 0 state)
       state)
      (_ (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--UI-init total-recall--UI)
#+end_src

**** Report
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       05a4ce8c-583a-43d2-9dde-af32164d1a97
:END:

~report :â‰¡ Report#mk()~ is a report. ~report#add string~ adds the string ~string~ to the
report. ~report#string()~ is string representation of the report.


#+begin_src emacs-lisp
;; Report

(defun total-recall--Report-membrane (msg)
  "Process incoming MSG for the report actor.
MSG is a list or symbol, such as `(add LINE)` or `string`.
Returns a list containing the instruction to execute."
  (pcase msg
    ((or :string `(:add ,_line)) t)
    (_ nil)))

(defun total-recall--Report-tx (state msg)
  "Handle transaction INST for the report actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a list or symbol, such as `(add LINE)` or `string`.
Updates MEMORY based on INST."
  (let ((self (gethash :self state))
        (lines (gethash :lines state)))

    (pcase msg
      (`(:add ,line)
       (puthash :lines (cons line lines) state)
       `(,state ,self))

      (:string
       `(,state ,(string-join (reverse lines) "\n"))))))

(defun total-recall--Report-init (_data)
  "Initialize a report actor with DATA.
DATA is ignored in this implementation.
Returns a state hash table for the report actor."
  (let ((state (total-recall--Actor-state #'total-recall--Report-membrane #'total-recall--Report-tx)))
    (puthash :lines '() state)
    state))

(total-recall--Actor #'total-recall--Report-init total-recall--Report)
#+end_src


#+begin_src emacs-lisp :tangle "total-recall-test.el"
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Report ()
  (let ((report (total-recall--Report t)))
    (total-recall--add report "line1")
    (total-recall--add report "line2")
    (should (string= (total-recall--string report) "line1\nline2"))))
#+end_src

**** Rating
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       4187a5b0-15c1-49fc-9962-7dd5802e4f25
:END:

~rating :â‰¡ Rating#mk date id value~ is a rating of the entity denoted by the string ~id~ at
date ~date~, lisp timestamp, with the value ~value~, a symbol. ~rating#struct()~ is the
list ~date, id, value~.


#+begin_src emacs-lisp
;; Rating

(defun total-recall--Rating-membrane (msg)
  "Process incoming MSG for the rating actor.
MSG is a symbol like `struct`, `date`, or `value`.
Returns a list containing the corresponding instruction."
  (pcase msg
    ((or :struct :date :value) t)
    (_ nil)))

(defun total-recall--Rating-tx (state msg)
  "Handle transaction INST for the rating actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a symbol like `struct`, `date`, or `value`.
Updates MEMORY with the requested data."
  (let ((date (gethash :date state))
        (id (gethash :id state))
        (value (gethash :value state)))
    (pcase msg
      (:struct `(,state ,`(,date ,id ,value)))
      (:date `(,state ,date))
      (:value `(,state ,value)))))

(defun total-recall--Rating-eq (r1 r2)
  "Check if rating actors R1 and R2 are equal.
R1 and R2 are rating actors.
Returns t if their structures are equal, nil otherwise."
  (equal (total-recall--struct r1)
         (total-recall--struct r2)))

(defun total-recall--Rating-init (data)
  "Initialize a rating actor with DATA.
DATA is a list of (DATE ID VALUE), where DATE is a timestamp,
ID is a UUID string, and VALUE is a symbol.
Returns a state hash table for the rating actor."
  (let ((state (total-recall--Actor-state #'total-recall--Rating-membrane #'total-recall--Rating-tx)))
    (pcase data
      (`(,date ,id ,value)
       (puthash :date date state)
       (puthash :id id state)
       (puthash :value value state)))

    state))

(total-recall--Actor #'total-recall--Rating-init total-recall--Rating)
#+end_src


#+begin_src emacs-lisp :tangle "total-recall-test.el"
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Rating ()
  (should (eq t t)))
#+end_src

**** total-recall-database
:PROPERTIES:
:ID:       7a2f9b87-a2f8-4fd1-991c-deab4100614c
:END:

#+begin_src emacs-lisp
(defcustom total-recall-database (file-name-concat (expand-file-name user-emacs-directory) "total-recall-test.sqlite3")
  "Specifies the path to the Total Recall SQLite database.
This is a string representing the file path for storing review data."
  :type 'string
  :group 'total-recall)
#+end_src

**** DB
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       aee4f045-f225-4e4c-a145-0cb2baad2186
:END:

~db :â‰¡ DB#mk db-path~ is a database that writes its data to the file denoted by the
string ~db-path~. ~db#save rating~ saves the rating ~rating~. ~db#ratings id~ is the list of
ratings associated with the given ~id~. ~db#stop()~ releases the resources associated
with ~db~.


#+begin_src emacs-lisp
;; DB

(defun total-recall--DB-membrane (msg)
  "Process incoming MSG for the database actor.
MSG is a list like `(save RATING)`, `(ratings ID)`, or `stop`.
Returns a list containing the corresponding instruction."
  (pcase msg
    ((or :stop `(:save ,_rating) `(:ratings ,_id)) t)
    (_ nil)))

(defun total-recall--DB-tx (state msg)
  "Handle transaction INST for the database actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is a list or symbol like `(save RATING)`, `(ratings ID)`, or `stop`.
Updates MEMORY based on INST."
  (let ((self (gethash :self state))
        (sqlite (gethash :sqlite state)))
    (pcase msg
      (`(:save ,rating)
       (pcase (total-recall--struct rating)
         (`(,date ,id ,value)
          (let ((row nil))
            (setq row
                  (list
                   (if (memq value '(success failure skip))
                       (symbol-name value)
                     (error "Unexpected value: value = %s" value))

                   (if (total-recall--string-uuid-p id)
                       id
                     (error "ID is not a UUID string: id = %s" id))

                   (format-time-string "%FT%TZ" (time-convert date 'list) t)))

            (sqlite-execute
             sqlite
             "INSERT INTO exercise_log (type, id, time) VALUES (?, ?, ?)"
             row)))

         (struct (error "Unexpected struct: struct = %s" struct)))
       `(,state ,self))

      (`(:ratings ,id)
       (unless (total-recall--string-uuid-p id)
         (error "ID is not a UUID string: id = %s" id))

       (let (rows ratings)
         (setq rows
               (sqlite-select
                sqlite
                "SELECT type, id, time FROM exercise_log WHERE id = ? ORDER BY time ASC"
                (list id)))

         (setq ratings
               (mapcar
                (lambda (row)
                  (pcase row
                    (`(,type ,id ,time)
                     (total-recall--Rating
                      `(,(parse-iso8601-time-string time)
                        ,(if (total-recall--string-uuid-p id) id
                           (error "ID is not a UUID string: id = %s" id))
                        ,(if (member type '("success" "failure" "skip")) (intern type)
                           (error "Unexpected type: id = %s, type = %s" type id)))))
                    (_ (error "Unexpected row: row = %s" row))))
                rows))

         `(,state ,ratings)))

      (:stop
       (sqlite-close sqlite)
       `(,state ,self)))))

(defun total-recall--DB-init (db-path)
  "Initialize a database actor with DB-PATH.
DB-PATH is a string or nil for an in-memory SQLite database.
Returns a state hash table for the database actor."
  (let ((state (total-recall--Actor-state #'total-recall--DB-membrane #'total-recall--DB-tx))
        (sqlite nil))

    (unless (sqlite-available-p)
      (error "Emacs must be compiled with built-in support for SQLite databases"))

    (setq sqlite (sqlite-open db-path))

    (unless (sqlite-select sqlite "SELECT name FROM sqlite_master WHERE type='table' AND name='exercise_log'")
      (sqlite-execute sqlite
                      "CREATE TABLE exercise_log (
                       type TEXT NOT NULL,
                       id TEXT NOT NULL,
                       time TEXT NOT NULL)"))
    (puthash :sqlite sqlite state)
    state))

(total-recall--Actor #'total-recall--DB-init total-recall--DB)
#+end_src


#+begin_src emacs-lisp :tangle "total-recall-test.el"
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--DB ()
  "Test Total Recall database functionality using an in-memory database."
  (let ((db (total-recall--DB nil))
        (id "123e4567-e89b-12d3-a456-426614174000")
        (time (parse-iso8601-time-string (format-time-string "%FT%TZ" (current-time) t)))
        (rating nil))

    (setq rating (total-recall--Rating (list time id 'success)))
    (should (eq (total-recall--save db rating) db))
    (should (total-recall--Rating-eq rating (car (total-recall--ratings db id))))))
#+end_src

**** Searcher
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID:       f1bbb813-e964-4687-994c-bda31c6ba27b
:END:

Given a path of a directory named ~root~ in the current file-system, ~searcher :â‰¡
Searcher#mk root DefinitionID ExerciseID~ is an actor used to search files and
directories. ~searcher#files()~ is a list of paths to regular files, each of which
contains at least one [[ref:83056aa9-1b7a-4678-a29e-7389db7f885f][definition]] or [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][exercise]].


#+begin_src emacs-lisp
;; Searcher

(defun total-recall--Searcher-membrane (msg)
  "Process incoming MSG for the searcher actor.
MSG is the symbol `files` to request file paths.
Returns a list containing the `files` instruction."
  (pcase msg
    (:files t)
    (_ nil)))

(defun total-recall--Searcher-tx (state msg)
  "Handle transaction INST for the searcher actor using MEMORY.
MEMORY is the actorâ€™s state hash table.
INST is the symbol `files` to search for files.
Updates MEMORY with the list of found file paths."
  (let ((cmd (gethash :cmd state)))
    (pcase msg
      (:files
       (let (matches)
         (with-temp-buffer
           (call-process-shell-command cmd nil `(,(current-buffer) nil) nil)
           (goto-char (point-min))
           (while (not (eobp))
             (let* ((line (buffer-substring-no-properties
                           (line-beginning-position) (line-end-position)))
                    (match (split-string line ":")))
               (push (car match) matches))
             (forward-line 1)))
         `(,state ,(delete-dups matches)))))))

(defun total-recall--Searcher-init (data)
  "Initialize a searcher actor with DATA.
DATA is a list of (ROOT DEF-ID EX-ID), where ROOT is a directory path,
DEF-ID and EX-ID are strings identifying definitions and exercises.
Returns a state hash table for the searcher actor."
  (let ((state (total-recall--Actor-state #'total-recall--Searcher-membrane #'total-recall--Searcher-tx)))
    (pcase data
      (`(,root ,def-id ,ex-id)

       (unless (file-directory-p (puthash :root root state))
         (error "Root is not a directory: root = %s" root))

       (let ((ripgrep total-recall-ripgrep-cmd))
         (unless (stringp (puthash :ripgrep (executable-find ripgrep) state))
           (error "Ripgrep not found in PATH: ripgrep = %s" ripgrep)))

       (unless (stringp (puthash :def-id def-id state))
         (error "Def-id is not a string: def-id = %s" def-id))

       (unless (stringp (puthash :ex-id ex-id state))
         (error "Ex-id is not a string: ex-id = %s" ex-id))

       (puthash :cmd
                (format "%s -g '*.org' -i --no-heading -n --color=never -m 1 '%s' %s"
                        (gethash :ripgrep state)
                        (format "%s|%s" (gethash :def-id state) (gethash :ex-id state))
                        (gethash :root state))
                state)

       state)
      (_ (error "Unexpected data: data = %s" data)))))

(total-recall--Actor #'total-recall--Searcher-init total-recall--Searcher)
#+end_src

***** OrgKnowledgeFile
:PROPERTIES:
:TYPE: f590edb9-5fa3-4a07-8f3d-f513950d5663
:ID: b0c11bed-8c87-4c9b-b699-5d1c2230d0ad
:END:

A OrgKnowledgeFile is a path to a OrgFile such that:
- Its content contains a string ~# :ID: <uuid>~ such that ~<uuid>~ is equal to the [[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUID]]
  ~org-knowledge-file-type-id~.
- All headings of its associated associated [[ref:6eae3f77-b4fd-4956-bb2b-de2b459b4fb3][AST]] are either [[ref:83056aa9-1b7a-4678-a29e-7389db7f885f][OrgDefinitions]] or
  [[ref:a474c4de-9bd2-4c2b-8189-c91eb0ab9014][OrgExercises]].


Given a path ~path~, ~org-knowledge-file-p(path) = true~ iff ~path~ is an
OrgKnowledgeFile.


#+begin_src emacs-lisp
(defcustom total-recall-org-knowledge-file-type-id "066ef595-0505-48b5-930a-74a4242e9d0d"
  :type 'string
  :group 'total-recall)
#+end_src


#+begin_src emacs-lisp
(defun total-recall--org-knowledge-file-p (path)
  ;; TODO
  )
#+end_src

**** Node
:PROPERTIES:
:ID:       7b449631-bbec-4cf2-ae86-247871af14fe
:END:

Node :â‰¡ [[ref:9ed6dfab-89aa-4bfb-8bff-d7a357546f2f][UUID]]

**** Edge
:PROPERTIES:
:ID:       061bc1d1-d892-4bac-bc04-e21f3593646f
:END:

Edge :â‰¡ [[ref:061bc1d1-d892-4bac-bc04-e21f3593646f][Node]] Ã— Node

**** DAG
:PROPERTIES:
:ID:       6b1ab7c6-087a-4f2a-a317-cede19042a73
:END:

A DAG(nodes edges) is a directed acyclic graph. nodes is a set of [[ref:7b449631-bbec-4cf2-ae86-247871af14fe][Node]] and edges is a
set of [[ref:061bc1d1-d892-4bac-bc04-e21f3593646f][Edge]].

** discussion

Executing total-recall yields the following computation:
1. exs : Set(Exercise) of the user.
2. t : Time the calling time of total-recall
3. db : List(Record) where a Record#mk : Exercise Time Result â†’ Record
4. recall_probability : Exercise Time â†’ interval(0 1) the probability of recall of ex
   at time t infered from db by fitting a forgetting curve.
5. schedule : List(Exercise) built from exs and db to match Ï†(exs t).


1. schedule contains all exercises, so 1. is satisfied.
2. graph :â‰¡ ReferenceGraph#mk(exs)
3. roots : Set(exs) :â‰¡ the set of all roots in graph.
4. components :â‰¡ sort (map Î»r.ReachableComponent#mk(graph r) roots) <
5. schedule :â‰¡ fold [] (map components (Î»c.sort c <)) concat
6. threshold : interval(0 1)
7. high_low :â‰¡ Î»ex.(recall_probability(ex t) â‰¤ threshold) ? left(ex) right(ex)
8. high_priority low_priority :â‰¡ triage schedule high_low
9. schedule :â‰¡ high_priority + low_priority

* footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
