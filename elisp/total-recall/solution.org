# :ID:       cdbad43e-8627-4918-9881-0340cab623b5

#+PROPERTY: header-args:emacs-lisp :noweb yes :mkdirp yes :tangle total-recall.el

* Specification
:PROPERTIES:
:ID:       2b6a2d42-bfd0-4658-b25a-b1b7000d1b01
:END:

#+name: specification
#+begin_src org
TODO
#+end_src

* Header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetition system -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÖHRING
;; Author: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.9
;; Package-Requires: ((emacs "29.4"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<specification>>
;;
;;; Code:
#+end_src

* Dependencies

#+begin_src emacs-lisp
;; Dependencies

(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'cl-generic)
(require 'org)
(require 'time-date)
(require 'parse-time)
(require 'org-element)
(require 'cl-lib)
#+end_src

* Configuration

#+begin_src emacs-lisp
;; Configuration

(defgroup total-recall nil
  "Customization options for Total Recall.
This package provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "total-recall-")

(defcustom total-recall-root (expand-file-name "~")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-db-path (file-name-concat (expand-file-name user-emacs-directory) "total-recall-test.sqlite3")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-io-buffer-name "*TotalRecall*"
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-def-id "f590edb9-5fa3-4a07-8f3d-f513950d5663"
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-ex-id "b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8"
  ""
  :type 'string
  :group 'total-recall)
#+end_src

* Actor
** specification

~Instruction~ is finite set of symbols. ~Stack :≡ List(Instruction)~. ~Compiler :≡ Any →
Stack~. A ~memory~ is a mutable object such that:

- ~memory#self()~ is t or the address of an object,
- ~memory#compiler()~ is a compiler,
- ~memory#interpreter()~ is an interpreter,
- ~memory#stack()~ is a stack,
- ~memory#out()~ is an arbitrary value.

~Interpreter :≡ Memory Instruction → Memory~. Given ~interpreter : Interpreter~,
~interpreter(m i)~ has the same address as ~m~ but not necessarily the same values. ~Init
:≡ Any → Memory~. ~Actor :≡ Init → Any → Any → Any~. Given ~actor :≡ Actor(init data)~,
~actor(msg)~ is the reply of ~actor~ to the message ~msg~. The reply is computed as
follows. Given ~memory :≡ init(data)~, we have:

- actor(msg) ≡
  1. memory#stack memory#compiler()(msg)
  2. match memory#stack()
     - [inst] + rest →
       1. memory#stack rest
       2. memory#interpreter() memory#memory() inst
     - [] → memory#out()

~send actor msg~ sends the message ~msg~ to ~actor~ and returns its reply. In other words,
a type of actors is specified by an init function and actors communicate by passing
messages, keeping a protected internal memory. Also, an actor may rewrite its entire
memory as it sees fit.

** implementation

#+begin_src emacs-lisp
;; Actor

(defmacro total-recall--Actor (init name)
  `(defun ,name (data)
     (let* ((memory (funcall ,init data))
            (self (lambda (msg)
                    (let* ((compiler (gethash 'compiler memory))
                           (stack (puthash 'stack (funcall compiler msg) memory)))
                      (while (not (null stack))
                        (puthash 'stack (cdr stack) memory)
                        (funcall (gethash 'interpreter memory) memory (car stack))
                        (setq stack (gethash 'stack memory)))
                      (gethash 'out memory)))))
       (puthash 'self self memory)
       self)))

(defun total-recall--send (actor msg) (funcall actor msg))

(defun total-recall--Actor-memory (compiler interpreter)
  (let ((memory (make-hash-table :test 'eq)))
    (puthash 'compiler compiler memory)
    (puthash 'interpreter interpreter memory)
    (puthash 'stack '() memory)
    (puthash 'self t memory)
    (puthash 'out nil memory)
    memory))
#+end_src

** test

See: [[ref:3ca40a21-019b-4bba-b18b-bcec7282b445][Clock]]

* Messages
** specification

** implementation

#+begin_src emacs-lisp
(defmacro total-recall--message (name)
  `(defun ,(intern (concat "total-recall--" (symbol-name name))) (actor &rest args)
     (total-recall--send actor
                         (pcase args
                           ('() ',name)
                           (_ (cons ',name args))))))

(total-recall--message read)
(total-recall--message tick)
(total-recall--message tick2)
(total-recall--message start)
(total-recall--message add)
(total-recall--message string)
(total-recall--message buffer)
(total-recall--message minibuffer)
(total-recall--message buffer-name)
(total-recall--message files)
(total-recall--message process-files)
(total-recall--message process-file)
(total-recall--message process-exercises)
(total-recall--message process-exercise)
(total-recall--message id)
(total-recall--message path)
(total-recall--message question)
(total-recall--message answer)
(total-recall--message parse)
(total-recall--message select)
(total-recall--message show)
#+end_src

** test

* Utils

#+begin_src emacs-lisp
(defun total-recall--truncate-str (str)
  (truncate-string-to-width
   (replace-regexp-in-string "\n" " " (string-trim str))
   25
   0
   nil
   "…"))
#+end_src

* Clock
:PROPERTIES:
:ID:       3ca40a21-019b-4bba-b18b-bcec7282b445
:END:

** specification

Given a natural number named ~time~, ~clock :≡ Clock(time)~ is a Clock. It means that
~clock#read()~ is its current time and ~t :≡ clock#read(); clock#tick()#read() = t +
1~.

** implementation

#+begin_src emacs-lisp
;; Clock

(total-recall--Actor
 #'total-recall--Clock-init
 total-recall--Clock)

(defun total-recall--Clock-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Clock-compiler
                 #'total-recall--Clock-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--Clock-compiler (msg)
  (pcase msg
    ('read '(read))
    ('tick '(tick))
    ('tick2 '(tick tick))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Clock-interpreter (memory inst)
  (let ((time (gethash 'time memory)))

    (pcase inst
      ('read
       (puthash 'out time memory))

      ('tick
       (puthash 'time (+ time 1) memory)
       (puthash 'out (gethash 'self memory) memory))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test
:PROPERTIES:
:header-args:emacs-lisp+: :tangle "total-recall-test.el"
:END:

#+begin_src emacs-lisp
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Clock ()
  (let ((clock (total-recall--Clock 0)))
    (should (= (total-recall--read clock) 0))
    (should (= (total-recall--read (total-recall--tick clock)) 1))
    (should (= (total-recall--read (total-recall--tick2 clock)) 3))))
#+end_src

* DONE Report
** specification

~report :≡ Report()~ is a report. ~report#add(string)~ adds the string ~string~ to the
report. ~report#string()~ is string representation of the report.

** implementation

#+begin_src emacs-lisp
;; Report

(total-recall--Actor
 #'total-recall--Report-init
 total-recall--Report)

(defun total-recall--Report-init (data)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Report-compiler
                 #'total-recall--Report-interpreter)))
    (puthash 'lines '() memory)
    memory))

(defun total-recall--Report-compiler (msg)
  (pcase msg
    (`(add ,line)
     `(,msg))

    ('string
     `(,msg))

    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Report-interpreter (memory inst)
  (let ((self (gethash 'self memory))
        (lines (gethash 'lines memory)))
    (pcase inst
      (`(add ,line)
       (puthash 'lines (cons line lines) memory)
       (puthash 'out self memory))

      ('string
       (puthash 'out (string-join (reverse lines) "\n") memory))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test
:PROPERTIES:
:header-args:emacs-lisp+: :tangle "total-recall-test.el"
:END:

#+begin_src emacs-lisp
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Report ()
  (let ((report (total-recall--Report t)))
    (total-recall--add report "line1")
    (total-recall--add report "line2")
    (should (string= (total-recall--string report) "line1\nline2"))))
#+end_src

* DONE Searcher
** specification

Given a path of a directory named ~root~ in the current file-system, ~searcher :≡
Searcher root~ is an actor used to search files and directories satisfying some
predicates. ~searcher#files()~ is a list of paths to regular files, each of which
contains at least one definition or exercise. A regular file contains a definition if
it contains the string:
#+begin_example
:ID: DefinitionID
#+end_example

where ~DefinitionID~ stands for the ID of the Definition type. A regular file contains
an exercise if it contains the string:
#+begin_example
:ID: ExerciseID
#+end_example

where ~ExerciseID~ stands for the ID of the Exercise type.

** implementation

#+begin_src emacs-lisp
;; Searcher

(total-recall--Actor
 #'total-recall--Searcher-init
 total-recall--Searcher)

(defun total-recall--Searcher-init (data)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Searcher-compiler
                 #'total-recall--Searcher-interpreter)))
    (pcase data
      (`(,root ,def-id ,ex-id)

       (unless (file-directory-p (puthash 'root root memory))
         (error "root is not a directory. root = %s" root))

       (let ((ripgrep "rg"))
         (unless (stringp (puthash 'ripgrep (executable-find ripgrep) memory))
           (error "ripgrep not found in PATH. ripgrep = %s" ripgrep)))

       (unless (stringp (puthash 'def-id def-id memory))
         (error "def-id is not a string. def-id = %s" def-id))

       (unless (stringp (puthash 'ex-id ex-id memory))
         (error "ex-id is not a string. ex-id = %s" ex-id))

       (puthash
        'cmd
        (format "%s -g '*.org' -i --no-heading -n --color=never -m 1 '%s' %s"
                (gethash 'ripgrep memory)
                (format "%s|%s" (gethash 'def-id memory) (gethash 'ex-id memory))
                (gethash 'root memory))
        memory)

       memory)
      (_ (error "Unexpected data. data = %s" data)))))

(defun total-recall--Searcher-compiler (msg)
  (pcase msg
    ('files
     '(files))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Searcher-interpreter (memory inst)
  (let ((ripgrep (gethash 'ripgrep memory))
        (def-id (gethash 'def-id memory))
        (ex-id (gethash 'ex-id memory))
        (cmd (gethash 'cmd memory)))
    (pcase inst
      ('files
       (let (matches)
         (with-temp-buffer
           (call-process-shell-command cmd nil `(,(current-buffer) nil) nil)
           (goto-char (point-min))
           (while (not (eobp))
             (let* ((line (buffer-substring-no-properties
                           (line-beginning-position) (line-end-position)))
                    (match (split-string line ":")))
               (push (car match) matches))
             (forward-line 1)))
         (puthash 'out (delete-dups matches) memory)))
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* DONE Exercise
** specification

~exercise :≡ Exercise(id path question answer)~ represents an exercise. ~exercise#id()~
is a UUID string. ~exercise#question()~, ~exercise#answer()~ are strings. ~exercise#path()~
is a string of the form ~A/B/…/Z~ that locates the exercise relative to its context
/i.e./ The exercise is about ~Z~ which parent heading is ~…~ up until ~A~.

** implementation

#+begin_src emacs-lisp
;; Exercise

(total-recall--Actor
 #'total-recall--Exercise-init
 total-recall--Exercise)

(defun total-recall--Exercise-init (data)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Exercise-compiler
                 #'total-recall--Exercise-interpreter)))
    (pcase data
      (`(,id ,path ,question ,answer)
       (puthash 'id id memory)
       (puthash 'path path memory)
       (puthash 'question question memory)
       (puthash 'answer answer memory)
       memory)
      (_
       (error "Unexpected data. data = %s" data)))))

(defun total-recall--Exercise-compiler (msg)
  (pcase msg
    ('id
     `(id))

    ('path
     `(path))

    ('question
     `(question))

    ('answer
     `(answer))

    ('string
     `(string))

    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Exercise-interpreter (memory inst)
  (let ((id (gethash 'id memory))
        (path (gethash 'path memory))
        (question (gethash 'question memory))
        (answer (gethash 'answer memory)))

    (pcase inst
      ('id
       (puthash 'out id memory))

      ('path
       (puthash 'out path memory))

      ('question
       (puthash 'out question memory))

      ('answer
       (puthash 'out answer memory))

      ('string
       (puthash 'out (string-join `("Exercise(" ,id ,path ,(total-recall--truncate-str question) ,(total-recall--truncate-str answer) ")") " ") memory))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* DONE Definition
** specification

~definition :≡ Definition(id path content)~ represents a definition. ~definition#id()~ is
a UUID string. ~definition#content()~ is a string. ~definition#path()~ is a string of the
form ~A/B/…/Z~ that locates the definition relative to its context /i.e./ The definition
is about ~Z~ which parent heading is ~…~ up until ~A~. ~definition~ may be viewed as an
exercise where the answer is the content and the question asks what is the definition
associated to the path.

** implementation

#+begin_src emacs-lisp
;; Definition

(total-recall--Actor
 #'total-recall--Definition-init
 total-recall--Definition)

(defun total-recall--Definition-init (data)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Definition-compiler
                 #'total-recall--Definition-interpreter)))
    (pcase data
      (`(,id ,path ,content)
       (puthash 'id id memory)
       (puthash 'path path memory)
       (puthash 'content content memory)
       memory)
      (_
       (error "Unexpected data. data = %s" data)))))

(defun total-recall--Definition-compiler (msg)
  (pcase msg
    ('id
     `(id))

    ('path
     `(path))

    ('content
     `(content))

    ('question
     `(question))

    ('answer
     `(content))

    ('string
     '(string))

    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Definition-interpreter (memory inst)
  (let ((id (gethash 'id memory))
        (path (gethash 'path memory))
        (content (gethash 'content memory)))

    (pcase inst
      ('id
       (puthash 'out id memory))

      ('path
       (puthash 'out path memory))

      ('content
       (puthash 'out content memory))

      ('question
       (puthash 'out "Definition?" memory))

      ('string
       (puthash 'out (string-join `("Definition(" ,id ,path ,(total-recall--truncate-str content) ")") " ") memory))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* DONE Parser
** specification

~parser :≡ Parser(def-id ex-id)~ is a parser such that ~parser#parse(file)~ is a list of
Exercises found in ~file~ content and ordered depth first relative to tree of headings.
~file~ is a path to an Org Mode file. ~def-id~ and ~ex-id~ are strings that identify
headings that are considered to be definitions or exercises /i.e./ the ~:TYPE:~ property
has a value equal to one of these values.

** implementation

#+begin_src emacs-lisp
;; Parser

(total-recall--Actor
 #'total-recall--Parser-init
 total-recall--Parser)

(defun total-recall--Parser-init (data)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Parser-compiler
                 #'total-recall--Parser-interpreter)))
    (pcase data
      (`(,def-id ,ex-id)
       (puthash 'def-id def-id memory)
       (puthash 'ex-id ex-id memory)
       memory)
      (_
       (error "Unexpected data. data = %s" data)))))

(defun total-recall--Parser-compiler (msg)
  (pcase msg
    (`(parse ,file) `(,msg))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Parser-interpreter (memory inst)
  (let ((def-id (gethash 'def-id memory))
        (ex-id (gethash 'ex-id memory)))
    (pcase inst
      (`(parse ,file)
       (puthash
        'out
        (with-temp-buffer
          (insert-file-contents file)
          (org-mode)
          (org-fold-show-all)
          (let ((org-element-use-cache nil))
            (total-recall--node-depth-first
             (org-element-parse-buffer 'greater-element)
             #'total-recall--node-to-element)))
        memory))
      (_ (error "Unexpected instruction. inst = %s" inst)))))

(defun total-recall--node-depth-first (node func)
  "Return the list of results from calling FUNC on NODE."
  (let ((head
         (mapcan
          (lambda (node) (total-recall--node-depth-first node func))
          (org-element-contents node)))
        (last (funcall func node)))
    (pcase last
      (:err head)
      (_ (append head (list last))))))

(defun total-recall--node-to-element (node)
  "Convert NODE to an element, trying exercise first, then definition if exercise fails."
  (let ((exercise-result (total-recall--node-to-exercise node)))
    (if (eq exercise-result :err)
        (total-recall--node-to-definition node)
      exercise-result)))

(defun total-recall--node-to-exercise (node)
  "Return an exercise built from NODE, or `:err' if not possible.
If NODE is expected to be an exercise based on its type but its
structure is invalid, raise an error."
  (let (should-be-exercise id list-headline question answer)

    (setq should-be-exercise
          (and (eq (org-element-type node) 'headline)
               (string= (org-element-property :TYPE node) total-recall-ex-id)))

    (if should-be-exercise
        (progn
          (setq id (org-element-property :ID node))
          (unless (stringp id) (error "Exercise has no ID property"))
          (setq list-headline
                (seq-filter
                 (lambda (child) (eq (org-element-type child) 'headline))
                 (org-element-contents node)))
          (pcase (length list-headline)
            (0 (error "Exercise has no question nor answer. id = %s" id))
            (1 (error "Exercise has no answer. id = %s" id))
            (_
             (setq question (total-recall--node-to-string (car list-headline)))
             (setq answer (total-recall--node-to-string (cadr list-headline)))))

          (total-recall--Exercise
           (list
            id
            (total-recall--node-subject node)
            question
            answer)))
      :err)))

(defun total-recall--node-to-definition (node)
  "Return an definition built from NODE, or `:err' if not possible.
If NODE is expected to be an definition based on its type but its
structure is invalid, raise an error."
  (let (should-be-definition id content)

    (setq should-be-definition
          (and (eq (org-element-type node) 'headline)
               (string= (org-element-property :TYPE node) total-recall-def-id)))

    (if should-be-definition
        (progn
          (setq id (org-element-property :ID node))
          (unless (stringp id) (error "Definition has no ID property"))
          (setq content (total-recall--node-to-string node))
          (total-recall--Definition
           (list
            id
            (total-recall--node-subject node)
            content
            )))
      :err)))

(defun total-recall--node-to-string (node)
  "Return the string associated with NODE, leveled to level 1."
  (replace-regexp-in-string
   "\\`\\*+" "*"
   (string-trim
    (buffer-substring-no-properties
     (org-element-property :begin node)
     (org-element-property :end node)))))

(defun total-recall--node-subject (node)
  "Return the subject of NODE.
A subject is a string like A/B/C, where A and B are the titles of the
parents of the node, and C is the title of the node. A node's title
is the string of the relevant headline."
  (string-join
   (reverse
    (org-element-lineage-map node
        (lambda (parent) (org-element-property :raw-value parent))
      '(headline)
      t))
   "/"))
#+end_src

** test

* TODO DB
** specification

- DB#mk : FilePath → DB
  - π#save : Exercise Rating → DB
  - π#stop() : 'ok

** implementation

#+begin_src emacs-lisp
;; DB

(total-recall--Actor
 #'total-recall--DB-init
 total-recall--DB)

(defun total-recall--DB-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--DB-compiler
                 #'total-recall--DB-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--DB-compiler (msg)
  (pcase msg
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--DB-interpreter (memory inst)
  (let ()
    (pcase inst
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO Planner
** specification

~planner :≡ Planner db~ is a planner. ~planner#select exercises~ selects exercises to be
reviewed at the time of the call given data represented by the database ~db~.

** implementation

#+begin_src emacs-lisp
;; Planner

(total-recall--Actor
 #'total-recall--Planner-init
 total-recall--Planner)

(defun total-recall--Planner-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Planner-compiler
                 #'total-recall--Planner-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--Planner-compiler (msg)
  (pcase msg
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Planner-interpreter (memory inst)
  (let ()
    (pcase inst
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO UI
** specification
** implementation

#+begin_src emacs-lisp
;; UI

(total-recall--Actor
 #'total-recall--UI-init
 total-recall--UI)

(defun total-recall--UI-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--UI-compiler
                 #'total-recall--UI-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--UI-compiler (msg)
  (pcase msg
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--UI-interpreter (memory inst)
  (let ()
    (pcase inst
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test
* DONE IO
** specification

Given a string ~name~, an ~io :≡ IO(name)~ represents input/outputs of the current
program. ~io#buffer(s)~ writes the string ~s~ to an output buffer named ~name~.
~io#minibuffer(s)~ writes the string ~s~ to Emacs minibuffer. ~io#buffer-name()~ is the
name of the buffer ~io#buffer()~.

** implementation

#+begin_src emacs-lisp
;; IO

(total-recall--Actor
 #'total-recall--IO-init
 total-recall--IO)

(defun total-recall--IO-init (name)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--IO-compiler
                 #'total-recall--IO-interpreter)))
    (puthash 'buffer (get-buffer-create name) memory)
    (puthash 'name (buffer-name (gethash 'buffer memory)) memory)
    memory))

(defun total-recall--IO-compiler (msg)
  (pcase msg
    (`(minibuffer ,string)
     `(,msg))

    (`(buffer ,string)
     `(,msg))

    ('buffer-name
     `(,msg))

    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--IO-interpreter (memory inst)
  (let ((self (gethash 'self memory))
        (buffer (gethash 'buffer memory))
        (name (gethash 'name memory)))

    (pcase inst
      (`(minibuffer ,string)
       (message "%s" (string-trim string))
       (puthash 'out self memory))

      (`(buffer ,string)
       (with-current-buffer buffer
         (insert (string-join (list string "\n"))))
       (puthash 'out self memory))

      ('buffer-name
       (puthash 'out name memory))

      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO TotalRecall
** specification

~tr :≡ TotalRecall root db-path~ is an actor such that ~tr#start()~ searches for Org Mode
files under ~root~ containing elements like exercises and/or definitions. For each
file, the headings are interpreted as a tree and the elements are ordered in a depth
first manner. The list of elements is mapped to a list of exercises which is then
prunned using data in ~db-path~ and a planner object. The prunned list is then sent to
the UI to be presented to the user. Data gathered from the data is then saved to
~db-path~. Finally, a report of execution is returned to the caller.

** implementation

#+begin_src emacs-lisp
;; TotalRecall

(total-recall--Actor
 #'total-recall--TotalRecall-init
 total-recall--TotalRecall)

(defun total-recall--TotalRecall-init (data)
  (pcase data
    (`(,root ,db-path ,def-id ,ex-id)
     (let ((memory (total-recall--Actor-memory
                    #'total-recall--TotalRecall-compiler
                    #'total-recall--TotalRecall-interpreter)))
       (puthash 'root root memory)
       (puthash 'db-path db-path memory)
       (puthash 'searcher (total-recall--Searcher (list root def-id ex-id)) memory)
       (puthash 'parser (total-recall--Parser (list def-id ex-id)) memory)
       (puthash 'db (total-recall--DB db-path) memory)
       (puthash 'planner (total-recall--Planner (gethash 'db memory)) memory)
       (puthash 'ui (total-recall--UI t) memory)
       (puthash 'nbr-files 0 memory)
       (puthash 'nbr-exercises 0 memory)
       memory))
    (_ (error "Unexpected data. data ≡ %s" data))))

(defun total-recall--TotalRecall-compiler (msg)
  (pcase msg
    ('start '(start))
    (`(process-files ,files) `(,msg))
    (`(process-file ,file) `(,msg))
    (`(process-exercises ,exercises) `(,msg))
    (`(process-exercise ,exercise) `(,msg))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--TotalRecall-interpreter (memory inst)
  (let ((self (gethash 'self memory))
        (root (gethash 'root memory))
        (db-path (gethash 'db-path memory))
        (searcher (gethash 'searcher memory))
        (parser (gethash 'parser memory))
        (db (gethash 'db memory))
        (planner (gethash 'planner memory))
        (ui (gethash 'ui memory))
        (nbr-files (gethash 'nbr-files memory))
        (nbr-exercises (gethash 'nbr-exercises memory))
        (report (gethash 'report memory)))

    (pcase inst
      ('start
       (let ((nbr-files (puthash 'nbr-files 0 memory))
             (nbr-exercises (puthash 'nbr-exercises 0 memory))
             (report (puthash 'report (total-recall--Report t) memory)))
         (total-recall--add report "TotalRecall started.")
         (total-recall--add report (format "Definitions and exercises under %s will be reviewed." root))
         (total-recall--add report (format "Review results will be saved in %s." db-path))
         (total-recall--process-files self (total-recall--files searcher))
         (total-recall--add report (format "%s files have been reviewed." (gethash 'nbr-files memory)))
         (total-recall--add report (format "%s exercises have been reviewed." (gethash 'nbr-exercises memory)))
         (puthash 'out report memory)))

      (`(process-files ,files)
       (pcase files
         ('()
          (puthash 'out self memory))
         (`(,file . ,files)
          (total-recall--process-file self file)
          (puthash 'nbr-files (+ nbr-files 1) memory)
          (total-recall--process-files self files))))

      (`(process-file ,file)
       (total-recall--add report (format "file = %s" file))
       (total-recall--process-exercises self (total-recall--parse parser file))
       (puthash 'out self memory))

      (`(process-exercises ,exercises)
       (pcase exercises
         ('()
          (puthash 'out self memory))
         (`(,exercise . ,exercises)
          (total-recall--process-exercise self exercise)
          (puthash 'nbr-exercises (+ nbr-exercises 1) memory)
          (total-recall--process-exercises self exercises))))

      (`(process-exercise ,exercise)
       (total-recall--add report (format "exercise = %s %s" (total-recall--id exercise) (total-recall--path exercise)))
       (puthash 'out self memory))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* DONE total-recall
** specification

~total-recall()~ implements the [[ref:2b6a2d42-bfd0-4658-b25a-b1b7000d1b01][specification]].

** implementation

#+begin_src emacs-lisp
;; total-recall

;;;###autoload
(defun total-recall ()
  (interactive)
  (let* ((tr (total-recall--TotalRecall (list
                                         total-recall-root
                                         total-recall-db-path
                                         total-recall-def-id
                                         total-recall-ex-id)))
         (report (total-recall--start tr))
         (io (total-recall--IO total-recall-io-buffer-name)))
    (total-recall--buffer io (total-recall--string report))
    (total-recall--minibuffer io (format "total-recall execution finished. Report written to the buffer named: %s" (total-recall--buffer-name io)))))
#+end_src

** test

* Footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
