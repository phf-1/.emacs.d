# :ID:       cdbad43e-8627-4918-9881-0340cab623b5

#+PROPERTY: header-args:emacs-lisp :noweb yes :mkdirp yes :tangle total-recall.el

* Specification
:PROPERTIES:
:ID:       2b6a2d42-bfd0-4658-b25a-b1b7000d1b01
:END:

#+name: specification
#+begin_src org
TODO
#+end_src

* Header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetition system -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÖHRING
;; Author: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.9
;; Package-Requires: ((emacs "29.4"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<specification>>
;;
;;; Code:
#+end_src

* Dependencies

#+begin_src emacs-lisp
;; Dependencies

(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'cl-generic)
(require 'org)
(require 'time-date)
(require 'parse-time)
(require 'org-element)
(require 'cl-lib)
#+end_src

* Configuration

#+begin_src emacs-lisp
;; Configuration

(defgroup total-recall nil
  "Customization options for Total Recall.
This package provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "total-recall-")

(defcustom total-recall-root (expand-file-name "~")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-db-path (file-name-concat (expand-file-name user-emacs-directory) "total-recall-test.sqlite3")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-io-buffer-name "*TotalRecall report buffer*"
  ""
  :type 'string
  :group 'total-recall)
#+end_src

* Actor
** specification

~Instruction~ is finite set of symbols.

~Stack :≡ List(Instruction)~.

~Compiler :≡ Any → Stack~.

A ~memory~ is a mutable object such that:
- ~memory#self()~ is t or the address of an object,
- ~memory#compiler()~ is a compiler,
- ~memory#interpreter()~ is an interpreter,
- ~memory#stack()~ is a stack,
- ~memory#out()~ is an arbitrary value.

~Interpreter :≡ Memory Instruction → Memory~. Given ~interpreter : Interpreter~,
~interpreter(m i)~ has the same address as ~m~ but not necessarily the same values.

~Init :≡ Any → Memory~.

~Actor :≡ Init → Any → Any → Any~. Given ~actor :≡ Actor(init data)~, ~actor(msg)~ is
the reply of ~actor~ to the message ~msg~. The reply is computed as follows. Given
~memory :≡ init(data)~, we have:

- actor(msg) ≡
  1. memory#stack memory#compiler()(msg)
  2. match memory#stack()
     - [inst] + rest →
       1. memory#stack rest
       2. memory#interpreter() memory#memory() inst
     - [] → memory#out()

~send actor msg~ sends the message ~msg~ to ~actor~ and returns its reply.

In other words, a type of actors is specified by an init function and actors
communicate by passing messages, keeping a protected internal memory. Also, an actor
may rewrite its entire memory as it sees fit.

** implementation

#+begin_src emacs-lisp
;; Actor

(defmacro total-recall--Actor (init name)
  `(defun ,name (data)
     (let* ((memory (funcall ,init data))
            (self (lambda (msg)
                    (let* ((compiler (gethash 'compiler memory))
                           (stack (puthash 'stack (funcall compiler msg) memory)))
                      (while (not (null stack))
                        (puthash 'stack (cdr stack) memory)
                        (funcall (gethash 'interpreter memory) memory (car stack))
                        (setq stack (gethash 'stack memory)))
                      (gethash 'out memory)))))
       (puthash 'self self memory)
       self)))

(defun total-recall--send (actor msg) (funcall actor msg))

(defun total-recall--Actor-memory (compiler interpreter)
  (let ((memory (make-hash-table :test 'eq)))
    (puthash 'compiler compiler memory)
    (puthash 'interpreter interpreter memory)
    (puthash 'stack '() memory)
    (puthash 'self t memory)    
    (puthash 'out nil memory)
    memory))
#+end_src

** test

See: [[ref:3ca40a21-019b-4bba-b18b-bcec7282b445][Clock]]

* Clock
:PROPERTIES:
:ID:       3ca40a21-019b-4bba-b18b-bcec7282b445
:END:

** specification

Given a natural number named ~time~, ~clock :≡ Clock(time)~ is a Clock. It means that
~clock#read()~ is its current time and ~t :≡ clock#read(); clock#tick()#read() = t +
1~.

** implementation

#+begin_src emacs-lisp
;; Clock
(total-recall--Actor
 #'total-recall--Clock-init
 total-recall--Clock)

;;;; Interface
(defun total-recall--read (actor)
  (total-recall--send actor 'read))

(defun total-recall--tick (actor)
  (total-recall--send actor 'tick))

(defun total-recall--tick2 (actor)
  (total-recall--send actor 'tick2))

;;;; Implementation
(defun total-recall--Clock-compiler (msg)
  (pcase msg
    ('read '(read))
    ('tick '(tick))
    ('tick2 '(tick tick))
    (_ (error "Unexpected msg. %s" msg))))

(defun total-recall--Clock-exec (memory inst)
  (pcase inst
    ('read
     (let ((time (gethash 'time memory)))
       (puthash 'out time memory)))

    ('tick
     (let ((time (gethash 'time memory)))
       (puthash 'time (+ time 1) memory)
       (puthash 'out (gethash 'self memory) memory)))

    (_ (error "Unexpected instruction. %s" inst))))

(defun total-recall--Clock-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Clock-compiler
                 #'total-recall--Clock-exec)))
    (puthash 'time time memory)
    memory))
#+end_src

** test
:PROPERTIES:
:header-args:emacs-lisp+: :tangle "total-recall-test.el"
:END:

#+begin_src emacs-lisp
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Clock ()
  (let ((clock (total-recall--Clock 0)))
    (should (= (total-recall--read clock) 0))
    (should (= (total-recall--read (total-recall--tick clock)) 1))
    (should (= (total-recall--read (total-recall--tick2 clock)) 3))))
#+end_src

* COMMENT Rating

- Rating#mk : Id → Rating
  - π#id() : Id

#+begin_src emacs-lisp
;; Rating
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--rating
  "Rating data structure."
  id)
#+end_src

*** rating-mk

#+begin_src emacs-lisp
(defun total-recall--rating-mk (id)
  ""
  (make-total-recall--rating :id id))
#+end_src

* COMMENT UI

- UI#mk : UI
  - π#show : Exercise → Rating | 'stop

#+begin_src emacs-lisp
;; UI
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--ui
  "UI data structure."
  id)
#+end_src

*** ui-mk

#+begin_src emacs-lisp
(defun total-recall--ui-mk (id)
  ""
  (make-total-recall--ui :id id))
#+end_src

* COMMENT Planner

- Planner#mk : DB → Planner
  - π#exercises : FilePath → List(Exercise)

#+begin_src emacs-lisp
;; Planner
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--planner
  "Planner data structure."
  id)
#+end_src

*** planner-mk

#+begin_src emacs-lisp
(defun total-recall--planner-mk (id)
  ""
  (make-total-recall--planner :id id))
#+end_src

* COMMENT Searcher

- ContentFile(root:DirPath) :≡ FilePath prefixed by root that contains at least one
  definition or exercise.

- Searcher#mk : root:DirPath → Searcher
  - π#files() : List(ContentFile(root))

#+begin_src emacs-lisp
;; Searcher
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--searcher
  "Searcher data structure."
  id)
#+end_src

*** searcher-mk

#+begin_src emacs-lisp
(defun total-recall--searcher-mk (id)
  ""
  (make-total-recall--searcher :id id))
#+end_src

* COMMENT DB

- DB#mk : FilePath → DB
  - π#save : Exercise Rating → DB
  - π#stop() : 'ok

#+begin_src emacs-lisp
;; DB
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--db
  "DB data structure."
  id)
#+end_src

*** db-mk

#+begin_src emacs-lisp
(defun total-recall--db-mk (id)
  ""
  (make-total-recall--db :id id))
#+end_src

* COMMENT Filepath

- Filepath#mk : Path → Filepath
  - π#path() : Path

#+begin_src emacs-lisp
;; Filepath
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--filepath
  "Filepath data structure."
  path)
#+end_src

*** filepath-mk

#+begin_src emacs-lisp
(defun total-recall--filepath-mk (path)
  ""
  (unless (file-regular-p path) (error "path is not a regular file. %s" path))
  (make-total-recall--filepath :path path))
#+end_src

* COMMENT Dirpath

- Dirpath#mk : Path → Dirpath
  - π#path() : Path

#+begin_src emacs-lisp
;; Dirpath
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--dirpath
  "Dirpath data structure."
  path)
#+end_src

*** dirpath-mk

#+begin_src emacs-lisp
(defun total-recall--dirpath-mk (path)
  ""
  (unless (file-directory-p path) (error "path is not a directory. %s" path))
  (make-total-recall--dirpath :path path))
#+end_src

* TODO IO

** specification

- IO#mk : Name → IO
  - π#buffer : String → IO
  - π#minibuffer : String → IO

** implementation

#+begin_src emacs-lisp
;; IO
(total-recall--Actor
 #'total-recall--IO-init-mk
 #'total-recall--IO-tx
 total-recall--IO)

;;;; Interface
(defun total-recall--minibuffer (io string)
  (total-recall--send io `(minibuffer ,string)))

(defun total-recall--buffer (io string)
  (total-recall--send io `(buffer ,string)))

(defun total-recall--buffer-name (io)
  (total-recall--send io 'buffer-name))

;;;; Implementation
(defun total-recall--IO-init-mk (buffer-name)
  (get-buffer-create buffer-name))

(defun total-recall--IO-tx (buffer msg)
  (pcase msg
    (`(minibuffer ,string)
     (message "%s" string)
     `(t ,buffer ,#'total-recall--IO-tx))

    (`(buffer ,string)
     (with-current-buffer buffer
       (insert string)
       (insert "\n"))
     `(t ,buffer ,#'total-recall--IO-tx))

    ('buffer-name
     `(t ,(buffer-name buffer) ,#'total-recall--IO-tx))

    (_
     (error "Unexpected message. message = %s" msg))))
#+end_src

** test

* TODO Report

** specification

- Report#mk() : Report
  - π#string() : String
  - π#add : String → Report

** implementation

#+begin_src emacs-lisp
;; Report
(total-recall--Actor
 #'total-recall--report-init-mk
 #'total-recall--report-tx
 total-recall--Report)

;;;; Interface
(defun total-recall--string (tr)
  (total-recall--send tr 'string))

(defun total-recall--report-add (tr line)
  (total-recall--send tr  ̀(add ,line)))

;;;; Implementation
(defun total-recall--report-init-mk ()
  '())

(defun total-recall--report-tx (lines msg)
  (pcase msg
    ('string
     `(,(string-join lines "\n") lines #'total-recall--report-tx))

    (`(add ,line)
     `(t ,(append lines line) #'total-recall--report-tx))

    (_
     (error "Unexpected message. message = %s" msg))))
#+end_src

** test

#+begin_src emacs-lisp
;; Report
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--report
  "Report data structure."
  strings)
#+end_src

*** report-mk

#+begin_src emacs-lisp
(defun total-recall--report-mk ()
  ""
  (make-total-recall--report
   :strings '()))
#+end_src

*** report-string

#+begin_src emacs-lisp
(defun total-recall--string (report)
  ""
  "report")
#+end_src

*** report-add

#+begin_src emacs-lisp
(defun total-recall--report-add (report string)
  ""
  report)
#+end_src

* TODO TotalRecall
** specification

- TotalRecall#mk : root:DirPath db-path:FilePath → TotalRecall
  - π#start() : Report :≡
    1. searcher :≡ Searcher#mk root
    2. db :≡ DB#mk db-path
    3. ui :≡ UI#mk()
    4. planner :≡ Planner#mk db
    5. files-counter : Nat :≡ 0
    6. exercises-counter : Nat :≡ 0
    7. report :≡ Report#mk()
    8. report#add "TotalRecall started."
    9. report#add "Definitions and exercises under #{root} will be reviewed."
    10. report#add "Review results will be saved in #{db-path}."
    11. files :≡ searcher#files()
    12. π#next-file()

** implementation

#+begin_src emacs-lisp
;; TotalRecall
(total-recall--Actor
 #'total-recall--TotalRecall-init-mk
 #'total-recall--TotalRecall-tx
 total-recall--TotalRecall)

;;;; Interface
(defun total-recall--start (tr)
  (total-recall--send tr 'start))

;;;; Implementation
(defun total-recall--TotalRecall-init-mk (any)
  (pcase-let ((`(,root ,db-path) any))
    (let* ((db (total-recall--DB db-path))
           (files-counter 0)
           (exercises-counter 0)
           (searcher (total-recall--Searcher root))
           (files (total-recall--Searcher-files searcher))
           (ui (total-recall--UI t))
           (planner (total-recall--Planner db))
           (report (total-recall--Report t)))
      `(,root
        ,db-path
        ,files
        ,planner
        ,ui
        ,db
        ,files-counter
        ,exercises-counter
        ,report))))

(defun total-recall--TotalRecall-tx (state msg )
  (pcase-let ((`(,root
                 ,db-path
                 ,files
                 ,planner
                 ,ui
                 ,db
                 ,files-counter
                 ,exercises-counter
                 ,report)
               state))

    (pcase msg
      ('start
       (total-report--Report-add report "TotalRecall started.")
       (total-report--Report-add report (format "Definitions and exercises under %s will be reviewed." root))
       (total-report--Report-add report (format "Review results will be saved in %s." db-path))
       (total-recall--send self 'next-file)
       `(,report ,state ,#'total-recall--TotalRecall-tx))

      ('next-file
       (total-report--Report-add report "next-file")
       `(,report ,state ,#'total-recall--TotalRecall-tx))

      (_
       (error "Unexpected message. message = %s" msg)))))
#+end_src

** test

#+begin_src emacs-lisp

#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--TotalRecall
  ""
  root db-path)
#+end_src

*** total-recall-mk

#+begin_src emacs-lisp
(defun total-recall--TotalRecall-mk (root db-path)
  ""
  (make-total-recall--TotalRecall
   :root root
   :db-path db-path))
#+end_src

*** total-recall-start

- π#start() : Report :≡


#+begin_src emacs-lisp
(defun total-recall--start (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-next-file

- π#next-file() : Report :≡
  - match files
    - [ ] → π#stop()
    - [file-path] + rest →
      1. files :≡ rest
      2. report#add "Reviewing exercises from file: #{file-path}."
      3. exercises :≡ planner#exercises file-path
      4. π#next-exercise()


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-next-file (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-next-exercise

- π#next-exercise() : Report :≡
  - match exercises
    - [ ] →
      1. files-counter :≡ files-counter + 1
      2. π#next-file()
    - [exercise] + rest →
      1. exercises :≡ rest
      2. report#add "Reviewing exercise: #{string-join(exercise#path())}."
      3. match ui#show exercise
         - 'stop → π#stop()
         - rating : Rating →
           1. exercises-counter :≡ exercises-counter + 1
           2. db#save exercise rating
           3. π#next-exercise()


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-next-exercise (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-stop

- π#stop() : Report :≡
  1. db#stop()
  2. report#add "Reviewing process is finished."
  3. report#add "#{exercises-counter} exercises or definitions have been reviewed from #{files-counter} files."
  4. report


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-stop (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

* DONE total-recall
** specification

~total-recall()~ implements the [[ref:2b6a2d42-bfd0-4658-b25a-b1b7000d1b01][specification]].

** implementation

#+begin_src emacs-lisp
;; total-recall

;;;###autoload
(defun total-recall ()
  (interactive)
  (let* ((tr (total-recall--TotalRecall `(,total-recall-root ,total-recall-db-path)))
         (report (total-recall--start tr))
         (io (total-recall--IO total-recall-io-buffer-name)))
    (total-recall--buffer io (total-recall--string report))
    (total-recall--minibuffer io (format "total-recall execution finished. Report written to %s" (total-recall--buffer-name io)))))
#+end_src

** test

* Footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
