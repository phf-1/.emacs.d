# :ID:       cdbad43e-8627-4918-9881-0340cab623b5

#+PROPERTY: header-args:emacs-lisp :noweb yes :mkdirp yes :tangle total-recall.el

* Specification
:PROPERTIES:
:ID:       2b6a2d42-bfd0-4658-b25a-b1b7000d1b01
:END:

#+name: specification
#+begin_src org
TODO
#+end_src

* Header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetition system -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÖHRING
;; Author: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.9
;; Package-Requires: ((emacs "29.4"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<specification>>
;;
;;; Code:
#+end_src

* Dependencies

#+begin_src emacs-lisp
;; Dependencies

(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'cl-generic)
(require 'org)
(require 'time-date)
(require 'parse-time)
(require 'org-element)
(require 'cl-lib)
#+end_src

* Configuration

#+begin_src emacs-lisp
;; Configuration

(defgroup total-recall nil
  "Customization options for Total Recall.
This package provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "total-recall-")

(defcustom total-recall-root (expand-file-name "~")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-db-path (file-name-concat (expand-file-name user-emacs-directory) "total-recall-test.sqlite3")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-io-buffer-name "*TotalRecall*"
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-def-id "f590edb9-5fa3-4a07-8f3d-f513950d5663"
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-ex-id "b0d53cd4-ad89-4333-9ef1-4d9e0995a4d8"
  ""
  :type 'string
  :group 'total-recall)
#+end_src

* Actor
** specification

~Instruction~ is finite set of symbols. ~Stack :≡ List(Instruction)~. ~Compiler :≡ Any →
Stack~. A ~memory~ is a mutable object such that:

- ~memory#self()~ is t or the address of an object,
- ~memory#compiler()~ is a compiler,
- ~memory#interpreter()~ is an interpreter,
- ~memory#stack()~ is a stack,
- ~memory#out()~ is an arbitrary value.

~Interpreter :≡ Memory Instruction → Memory~. Given ~interpreter : Interpreter~,
~interpreter(m i)~ has the same address as ~m~ but not necessarily the same values. ~Init
:≡ Any → Memory~. ~Actor :≡ Init → Any → Any → Any~. Given ~actor :≡ Actor(init data)~,
~actor(msg)~ is the reply of ~actor~ to the message ~msg~. The reply is computed as
follows. Given ~memory :≡ init(data)~, we have:

- actor(msg) ≡
  1. memory#stack memory#compiler()(msg)
  2. match memory#stack()
     - [inst] + rest →
       1. memory#stack rest
       2. memory#interpreter() memory#memory() inst
     - [] → memory#out()

~send actor msg~ sends the message ~msg~ to ~actor~ and returns its reply. In other words,
a type of actors is specified by an init function and actors communicate by passing
messages, keeping a protected internal memory. Also, an actor may rewrite its entire
memory as it sees fit.

** implementation

#+begin_src emacs-lisp
;; Actor

(defmacro total-recall--Actor (init name)
  `(defun ,name (data)
     (let* ((memory (funcall ,init data))
            (self (lambda (msg)
                    (let* ((compiler (gethash 'compiler memory))
                           (stack (puthash 'stack (funcall compiler msg) memory)))
                      (while (not (null stack))
                        (puthash 'stack (cdr stack) memory)
                        (funcall (gethash 'interpreter memory) memory (car stack))
                        (setq stack (gethash 'stack memory)))
                      (gethash 'out memory)))))
       (puthash 'self self memory)
       self)))

(defun total-recall--send (actor msg) (funcall actor msg))

(defun total-recall--Actor-memory (compiler interpreter)
  (let ((memory (make-hash-table :test 'eq)))
    (puthash 'compiler compiler memory)
    (puthash 'interpreter interpreter memory)
    (puthash 'stack '() memory)
    (puthash 'self t memory)
    (puthash 'out nil memory)
    memory))
#+end_src

** test

See: [[ref:3ca40a21-019b-4bba-b18b-bcec7282b445][Clock]]

* TODO Messages
** specification

** implementation

#+begin_src emacs-lisp
(defmacro total-recall--message (name)
  `(defun ,(intern (concat "total-recall--" (symbol-name name))) (actor &rest args)
     (total-recall--send actor
			 (pcase args
			   ('() ',name)
			   (_ (cons ',name args))))))

(total-recall--message read)
(total-recall--message tick)
(total-recall--message tick2)
(total-recall--message start)
(total-recall--message add)
(total-recall--message string)
(total-recall--message buffer)
(total-recall--message minibuffer)
(total-recall--message buffer-name)
(total-recall--message files)
#+end_src

** test

* Clock
:PROPERTIES:
:ID:       3ca40a21-019b-4bba-b18b-bcec7282b445
:END:

** specification

Given a natural number named ~time~, ~clock :≡ Clock(time)~ is a Clock. It means that
~clock#read()~ is its current time and ~t :≡ clock#read(); clock#tick()#read() = t +
1~.

** implementation

#+begin_src emacs-lisp
;; Clock

(total-recall--Actor
 #'total-recall--Clock-init
 total-recall--Clock)

(defun total-recall--Clock-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Clock-compiler
                 #'total-recall--Clock-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--Clock-compiler (msg)
  (pcase msg
    ('read '(read))
    ('tick '(tick))
    ('tick2 '(tick tick))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Clock-interpreter (memory inst)
  (let ((time (gethash 'time memory)))
    
    (pcase inst
      ('read
       (puthash 'out time memory))

      ('tick
       (puthash 'time (+ time 1) memory)
       (puthash 'out (gethash 'self memory) memory))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test
:PROPERTIES:
:header-args:emacs-lisp+: :tangle "total-recall-test.el"
:END:

#+begin_src emacs-lisp
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Clock ()
  (let ((clock (total-recall--Clock 0)))
    (should (= (total-recall--read clock) 0))
    (should (= (total-recall--read (total-recall--tick clock)) 1))
    (should (= (total-recall--read (total-recall--tick2 clock)) 3))))
#+end_src

* TODO Report
** specification

- Report#mk() : Report
  - π#string() : String
  - π#add : String → Report

** implementation

#+begin_src emacs-lisp
;; Report

(total-recall--Actor
 #'total-recall--Report-init
 total-recall--Report)

(defun total-recall--Report-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Report-compiler
                 #'total-recall--Report-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--Report-compiler (msg)
  (pcase msg
    (`(add ,line)
     `(,msg))

    ('string
     `(,msg))
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Report-interpreter (memory inst)
  (let ()
    (pcase inst
      (`(add ,line)
       memory)

      ('string
       (puthash 'out "report" memory))
      
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* DONE Searcher
** specification

Given a path of a directory named ~root~ in the current file-system, ~searcher :≡
Searcher root~ is an actor used to search files and directories satisfying some
predicates. ~searcher#files()~ is a list of paths to regular files, each of which
contains at least one definition or exercise. A regular file contains a definition if
it contains the string:
#+begin_example
:ID: DefinitionID
#+end_example

where ~DefinitionID~ stands for the ID of the Definition type. A regular file contains
an exercise if it contains the string:
#+begin_example
:ID: ExerciseID
#+end_example

where ~ExerciseID~ stands for the ID of the Exercise type.

** implementation

#+begin_src emacs-lisp
;; Searcher

(total-recall--Actor
 #'total-recall--Searcher-init
 total-recall--Searcher)

(defun total-recall--Searcher-init (data)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Searcher-compiler
                 #'total-recall--Searcher-interpreter)))
    (pcase data
      (`(,root ,def-id ,ex-id)

       (unless (file-directory-p (puthash 'root root memory))
	 (error "root is not a directory. root = %s" root))
       
       (let ((ripgrep "rg"))
	 (unless (stringp (puthash 'ripgrep (executable-find ripgrep) memory))
	   (error "ripgrep not found in PATH. ripgrep = %s" ripgrep)))

       (unless (stringp (puthash 'def-id def-id memory))
	 (error "def-id is not a string. def-id = %s" def-id))

       (unless (stringp (puthash 'ex-id ex-id memory))
	 (error "ex-id is not a string. ex-id = %s" ex-id))

       (puthash
	'cmd
	(format "%s -g '*.org' -i --no-heading -n --color=never -m 1 '%s' %s"
                (gethash 'ripgrep memory)
		(format "%s|%s" (gethash 'def-id memory) (gethash 'ex-id memory))
		(gethash 'root memory))
	memory)

       memory)
      (_ (error "Unexpected data. data = %s" data)))))

(defun total-recall--Searcher-compiler (msg)
  (pcase msg
    ('files
     '(files))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Searcher-interpreter (memory inst)
  (let ((ripgrep (gethash 'ripgrep memory))
	(def-id (gethash 'def-id memory))
	(ex-id (gethash 'ex-id memory))
	(cmd (gethash 'cmd memory)))
    (pcase inst
      ('files
       (let (matches)
	 (with-temp-buffer
	   (call-process-shell-command cmd nil `(,(current-buffer) nil) nil)
	   (goto-char (point-min))
	   (while (not (eobp))
             (let* ((line (buffer-substring-no-properties
			   (line-beginning-position) (line-end-position)))
		    (match (split-string line ":")))
               (push (car match) matches))
             (forward-line 1)))
	 (puthash 'out (delete-dups matches) memory)))
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO DB
** specification

- DB#mk : FilePath → DB
  - π#save : Exercise Rating → DB
  - π#stop() : 'ok

** implementation

#+begin_src emacs-lisp
;; DB

(total-recall--Actor
 #'total-recall--DB-init
 total-recall--DB)

(defun total-recall--DB-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--DB-compiler
                 #'total-recall--DB-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--DB-compiler (msg)
  (pcase msg
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--DB-interpreter (memory inst)
  (let ()
    (pcase inst
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO Planner
** specification

** implementation

#+begin_src emacs-lisp
;; Planner

(total-recall--Actor
 #'total-recall--Planner-init
 total-recall--Planner)

(defun total-recall--Planner-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Planner-compiler
                 #'total-recall--Planner-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--Planner-compiler (msg)
  (pcase msg
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--Planner-interpreter (memory inst)
  (let ()
    (pcase inst
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO UI
** specification
** implementation

#+begin_src emacs-lisp
;; UI

(total-recall--Actor
 #'total-recall--UI-init
 total-recall--UI)

(defun total-recall--UI-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--UI-compiler
                 #'total-recall--UI-interpreter)))
    (puthash 'time time memory)
    memory))

(defun total-recall--UI-compiler (msg)
  (pcase msg
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--UI-interpreter (memory inst)
  (let ()
    (pcase inst
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test
* DONE IO
** specification

Given a string ~name~, an ~io :≡ IO(name)~ represents input/outputs of the current
program. ~io#buffer(s)~ writes the string ~s~ to an output buffer named ~name~.
~io#minibuffer(s)~ writes the string ~s~ to Emacs minibuffer. ~io#buffer-name()~ is the
name of the buffer ~io#buffer()~.

** implementation

#+begin_src emacs-lisp
;; IO

(total-recall--Actor
 #'total-recall--IO-init
 total-recall--IO)

(defun total-recall--IO-init (name)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--IO-compiler
                 #'total-recall--IO-interpreter)))
    (puthash 'buffer (get-buffer-create name) memory)
    (puthash 'name (buffer-name (gethash 'buffer memory)) memory)    
    memory))

(defun total-recall--IO-compiler (msg)
  (pcase msg
    (`(minibuffer ,string)
     `(,msg))

    (`(buffer ,string)
     `(,msg))

    ('buffer-name
     `(,msg))
    
    ;; TODO
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--IO-interpreter (memory inst)
  (let ((self (gethash 'self memory))
	(buffer (gethash 'buffer memory))
	(name (gethash 'name memory)))
    
    (pcase inst
      (`(minibuffer ,string)
       (message "%s" (string-trim string))
       (puthash 'out self memory))

      (`(buffer ,string)
       (with-current-buffer buffer
	 (insert (string-join (list string "\n"))))
       (puthash 'out self memory))

      ('buffer-name
       (puthash 'out name memory))
      
      ;; TODO
      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* TODO TotalRecall
** specification

~tr :≡ TotalRecall root db-path~ is an actor such that ~tr#start()~ searches for Org Mode
files under ~root~ containing elements like exercises and/or definitions. For each
file, the headings are interpreted as a tree and the elements are ordered in a depth
first manner. The list of elements is mapped to a list of exercises which is then
prunned using data in ~db-path~ and a planner object. The prunned list is then sent to
the UI to be presented to the user. Data gathered from the data is then saved to
~db-path~. Finally, a report of execution is returned to the caller.

** implementation

#+begin_src emacs-lisp
;; TotalRecall

(total-recall--Actor
 #'total-recall--TotalRecall-init
 total-recall--TotalRecall)

(defun total-recall--TotalRecall-init (data)
  (pcase data
    (`(,root ,db-path ,def-id ,ex-id)
     (let ((memory (total-recall--Actor-memory
                    #'total-recall--TotalRecall-compiler
                    #'total-recall--TotalRecall-interpreter)))
       (puthash 'root root memory)
       (puthash 'db-path db-path memory)
       (puthash 'searcher (total-recall--Searcher (list root def-id ex-id)) memory)
       (puthash 'db (total-recall--DB db-path) memory)
       (puthash 'planner (total-recall--Planner (gethash 'db memory)) memory)
       (puthash 'ui (total-recall--UI t) memory)
       (puthash 'nbr-files 0 memory)
       (puthash 'nbr-exercises 0 memory)
       memory))
    (_ (error "Unexpected data. data ≡ %s" data))))

(defun total-recall--TotalRecall-compiler (msg)
  (pcase msg
    ('start '(start))
    (_ (error "Unexpected msg. msg = %s" msg))))

(defun total-recall--TotalRecall-interpreter (memory inst)
  (let ((root (gethash 'root memory))
        (db-path (gethash 'db-path memory))
        (searcher (gethash 'searcher memory))
        (db (gethash 'db memory))
        (planner (gethash 'planner memory))
        (ui (gethash 'ui memory))
        (nbr-files (gethash 'nbr-files memory))
        (nbr-exercises (gethash 'nbr-exercises memory))
        (report (gethash 'report memory)))

    (pcase inst
      ('start
       (let ((nbr-files (puthash 'nbr-files 0 memory))
             (nbr-exercises (puthash 'nbr-exercises 0 memory))
             (report (puthash 'report (total-recall--Report t) memory)))
         (total-recall--add report "TotalRecall started.")
         (total-recall--add report (format "Definitions and exercises under %s will be reviewed." root))
         (total-recall--add report (format "Review results will be saved in %s." db-path))
	 (total-recall--files searcher)
         ;; TODO
         (total-recall--add report (format "%s files have been reviewed." (gethash 'nbr-files memory)))
         (total-recall--add report (format "%s exercises have been reviewed." (gethash 'nbr-exercises memory)))
         (puthash 'out report memory)))

      (_ (error "Unexpected instruction. inst = %s" inst)))))
#+end_src

** test

* DONE total-recall
** specification

~total-recall()~ implements the [[ref:2b6a2d42-bfd0-4658-b25a-b1b7000d1b01][specification]].

** implementation

#+begin_src emacs-lisp
;; total-recall

;;;###autoload
(defun total-recall ()
  (interactive)
  (let* ((tr (total-recall--TotalRecall (list
					 total-recall-root
					 total-recall-db-path
					 total-recall-def-id
					 total-recall-ex-id)))
         (report (total-recall--start tr))
         (io (total-recall--IO total-recall-io-buffer-name)))
    (total-recall--buffer io (total-recall--string report))
    (total-recall--minibuffer io (format "total-recall execution finished. Report written to the buffer named: %s" (total-recall--buffer-name io)))))
#+end_src

** test

* Footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
