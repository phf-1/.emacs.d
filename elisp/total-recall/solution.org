# :ID:       cdbad43e-8627-4918-9881-0340cab623b5

#+PROPERTY: header-args:emacs-lisp :noweb yes :mkdirp yes :tangle total-recall.el

* Commentary
:PROPERTIES:
:ID:       2b6a2d42-bfd0-4658-b25a-b1b7000d1b01
:END:

#+name: commentary
#+begin_src org
TODO
#+end_src

* Header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetition system -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÖHRING
;; Author: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.9
;; Package-Requires: ((emacs "29.4"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<commentary>>
;;
;;; Code:
#+end_src

* Dependencies

#+begin_src emacs-lisp
;; Dependencies

(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'cl-generic)
(require 'org)
(require 'time-date)
(require 'parse-time)
(require 'org-element)
(require 'cl-lib)
#+end_src

* Configuration

#+begin_src emacs-lisp
;; Configuration

(defgroup total-recall nil
  "Customization options for Total Recall.
This package provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "total-recall-")

(defcustom total-recall-root (expand-file-name "~")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-db-path (file-name-concat (expand-file-name user-emacs-directory) "total-recall-test.sqlite3")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-io-buffer-name "*TotalRecall report buffer*"
  ""
  :type 'string
  :group 'total-recall)
#+end_src

* Actor
** specification

- Tx :≡ State Message → Message × State × Tx
- InitState :≡ Any → State
- Actor : init:InitState tx:Tx → Actor(init tx)
  - π : State → π
  - α : π
  - send α msg : Any

** implementation

#+begin_src emacs-lisp
;; Actor

(defmacro total-recall--Actor (init-state-mk init-tx name)
  `(defun ,name (init-state)
     (let ((state (funcall ,init-state-mk init-state))
           (tx ,init-tx))
       (lambda (message)
         (pcase (funcall tx state message)
           (`(,reply ,next-state ,next-tx)
            (setf state next-state)
            (setf tx next-tx)
            reply)
           (other
            (error "Unexpected transition. %s" other)))))))

(defun total-recall--send (actor msg) (funcall actor msg))
#+end_src

** test

See: [[ref:3ca40a21-019b-4bba-b18b-bcec7282b445][Clock]]

* Clock                                                            :noexport:
:PROPERTIES:
:ID:       3ca40a21-019b-4bba-b18b-bcec7282b445
:END:

** specification

- Clock : Nat → Clock
  - π#time() : Nat
  - π#tick() : Clock

** implementation

#+begin_src emacs-lisp
;; Clock

(defun total-recall--clock-read (clock)
  (total-recall--send clock 'read))

(defun total-recall--clock-tick (clock)
  (total-recall--send clock 'tick))

(defun total-recall--clock-init-state-mk (any)
  (unless
      (and (integerp any) (> any -1))
    (error "Unexpected init state. %s" any))
  any)

(defun total-recall--clock-tx (time msg)
  (pcase msg
    ('read
     (list time time #'total-recall--clock-tx))

    ('tick
     (list nil (+ time 1) #'total-recall--clock-tx))

    (_
     (error "Unexpected msg. %s" msg))))

(total-recall--Actor #'total-recall--clock-init-state-mk #'total-recall--clock-tx total-recall--Clock)
#+end_src

** test
:PROPERTIES:
:header-args:emacs-lisp+: :tangle "total-recall-test.el"
:END:

#+begin_src emacs-lisp
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Clock ()
  (let ((clock (total-recall--Clock 0)))
    (should (= (total-recall--clock-read clock) 0))
    (total-recall--clock-tick clock)
    (should (= (total-recall--clock-read clock) 1))))
#+end_src

* Rating

- Rating#mk : Id → Rating
  - π#id() : Id

#+begin_src emacs-lisp
;; Rating
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--rating
  "Rating data structure."
  id)
#+end_src

*** rating-mk

#+begin_src emacs-lisp
(defun total-recall--rating-mk (id)
  ""
  (make-total-recall--rating :id id))
#+end_src

* UI

- UI#mk : UI
  - π#show : Exercise → Rating | 'stop

#+begin_src emacs-lisp
;; UI
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--ui
  "UI data structure."
  id)
#+end_src

*** ui-mk

#+begin_src emacs-lisp
(defun total-recall--ui-mk (id)
  ""
  (make-total-recall--ui :id id))
#+end_src

* Planner

- Planner#mk : DB → Planner
  - π#exercises : FilePath → List(Exercise)

#+begin_src emacs-lisp
;; Planner
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--planner
  "Planner data structure."
  id)
#+end_src

*** planner-mk

#+begin_src emacs-lisp
(defun total-recall--planner-mk (id)
  ""
  (make-total-recall--planner :id id))
#+end_src

* Searcher

- ContentFile(root:DirPath) :≡ FilePath prefixed by root that contains at least one
  definition or exercise.

- Searcher#mk : root:DirPath → Searcher
  - π#files() : List(ContentFile(root))

#+begin_src emacs-lisp
;; Searcher
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--searcher
  "Searcher data structure."
  id)
#+end_src

*** searcher-mk

#+begin_src emacs-lisp
(defun total-recall--searcher-mk (id)
  ""
  (make-total-recall--searcher :id id))
#+end_src

* DB

- DB#mk : FilePath → DB
  - π#save : Exercise Rating → DB
  - π#stop() : 'ok

#+begin_src emacs-lisp
;; DB
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--db
  "DB data structure."
  id)
#+end_src

*** db-mk

#+begin_src emacs-lisp
(defun total-recall--db-mk (id)
  ""
  (make-total-recall--db :id id))
#+end_src

* Filepath

- Filepath#mk : Path → Filepath
  - π#path() : Path

#+begin_src emacs-lisp
;; Filepath
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--filepath
  "Filepath data structure."
  path)
#+end_src

*** filepath-mk

#+begin_src emacs-lisp
(defun total-recall--filepath-mk (path)
  ""
  (unless (file-regular-p path) (error "path is not a regular file. %s" path))
  (make-total-recall--filepath :path path))
#+end_src

* Dirpath

- Dirpath#mk : Path → Dirpath
  - π#path() : Path

#+begin_src emacs-lisp
;; Dirpath
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--dirpath
  "Dirpath data structure."
  path)
#+end_src

*** dirpath-mk

#+begin_src emacs-lisp
(defun total-recall--dirpath-mk (path)
  ""
  (unless (file-directory-p path) (error "path is not a directory. %s" path))
  (make-total-recall--dirpath :path path))
#+end_src

* IO

- IO#mk : Name → IO
  - π#print-to-buffer : String → IO
  - π#print-to-minibuffer : String → IO
  - π#buffer() : Buffer

#+begin_src emacs-lisp
;; IO
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--io
  "Io data structure."
  name
  buffer)
#+end_src

*** io-mk

#+begin_src emacs-lisp
(defun total-recall--io-mk (name)
  ""
  (unless (stringp name) (error "name is not a string. %s" path))
  (make-total-recall--io :name name :buffer (get-buffer-create name)))
#+end_src

*** io-print-to-buffer

#+begin_src emacs-lisp
(defun total-recall--io-print-to-buffer (io string)
  ""
  io)
#+end_src

*** io-print-to-minibuffer

#+begin_src emacs-lisp
(defun total-recall--io-print-to-minibuffer (io string)
  ""
  (message string)
  io)
#+end_src

* Report

- Report#mk() : Report
  - π#string() : String
  - π#add : String → Report

#+begin_src emacs-lisp
;; Report
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--report
  "Report data structure."
  strings)
#+end_src

*** report-mk

#+begin_src emacs-lisp
(defun total-recall--report-mk ()
  ""
  (make-total-recall--report
   :strings '()))
#+end_src

*** report-string

#+begin_src emacs-lisp
(defun total-recall--report-string (report)
  ""
  "report")
#+end_src

*** report-add

#+begin_src emacs-lisp
(defun total-recall--report-add (report string)
  ""
  report)
#+end_src

* TotalRecall

- TotalRecall#mk : root:DirPath db-path:FilePath → TotalRecall

#+begin_src emacs-lisp
;; TotalRecall
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--total-recall
  ""
  root db-path)
#+end_src

*** total-recall-mk

#+begin_src emacs-lisp
(defun total-recall--total-recall-mk (root db-path)
  ""
  (make-total-recall--total-recall
   :root root
   :db-path db-path))
#+end_src

*** total-recall-start

- π#start() : Report :≡
  1. searcher :≡ Searcher#mk root
  2. db :≡ DB#mk db-path
  3. ui :≡ UI#mk()
  4. planner :≡ Planner#mk db
  5. files-counter : Nat :≡ 0
  6. exercises-counter : Nat :≡ 0
  7. report :≡ Report#mk()
  8. report#add "TotalRecall started."
  9. report#add "Definitions and exercises under #{root} will be reviewed."
  10. report#add "Review results will be saved in #{db-path}."
  11. files :≡ searcher#files()
  12. π#next-file()


#+begin_src emacs-lisp
(defun total-recall--total-recall-start (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-next-file

- π#next-file() : Report :≡
  - match files
    - [ ] → π#stop()
    - [file-path] + rest →
      1. files :≡ rest
      2. report#add "Reviewing exercises from file: #{file-path}."
      3. exercises :≡ planner#exercises file-path
      4. π#next-exercise()


#+begin_src emacs-lisp
(defun total-recall--total-recall-next-file (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-next-exercise

- π#next-exercise() : Report :≡
  - match exercises
    - [ ] →
      1. files-counter :≡ files-counter + 1
      2. π#next-file()
    - [exercise] + rest →
      1. exercises :≡ rest
      2. report#add "Reviewing exercise: #{string-join(exercise#path())}."
      3. match ui#show exercise
         - 'stop → π#stop()
         - rating : Rating →
           1. exercises-counter :≡ exercises-counter + 1
           2. db#save exercise rating
           3. π#next-exercise()


#+begin_src emacs-lisp
(defun total-recall--total-recall-next-exercise (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-stop

- π#stop() : Report :≡
  1. db#stop()
  2. report#add "Reviewing process is finished."
  3. report#add "#{exercises-counter} exercises or definitions have been reviewed from #{files-counter} files."
  4. report


#+begin_src emacs-lisp
(defun total-recall--total-recall-stop (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

* total-recall

- total-recall() : Proposition :≡
  1. db-path : FilePath
  2. root : DirPath
  3. io-buffer-name : Name
  4. total-recall :≡ TotalRecall#mk root db-path
  5. io :≡ IO#mk io-buffer-name
  6. report :≡ total-recall#start()
  7. io#print-to-buffer report#string()
  8. io#print-to-minibuffer "total-recall execution finished. Report written to #{io#buffer()}".

#+begin_src emacs-lisp
;; total-recall
#+end_src

#+begin_src emacs-lisp
;;;###autoload
(defun total-recall ()
  ""
  (interactive)
  (let* ((db-path total-recall-db-path)
        (root total-recall-root)
        (io-buffer-name total-recall-io-buffer-name)
        (tr (total-recall--total-recall-mk root db-path))
        (io (total-recall--io-mk io-buffer-name))
        (report (total-recall--total-recall-start tr)))
    (total-recall--io-print-to-buffer io (total-recall--report-string report))
    (total-recall--io-print-to-minibuffer io (format "total-recall execution finished. Report written to %s" io-buffer-name))))
#+end_src

* Footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
