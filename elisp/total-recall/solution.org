# :ID:       cdbad43e-8627-4918-9881-0340cab623b5

#+PROPERTY: header-args:emacs-lisp :noweb yes :mkdirp yes :tangle total-recall.el

* Commentary
:PROPERTIES:
:ID:       2b6a2d42-bfd0-4658-b25a-b1b7000d1b01
:END:

#+name: commentary
#+begin_src org
TODO
#+end_src

* Header

#+begin_src emacs-lisp
;;; total-recall.el --- Spaced repetition system -*- lexical-binding: t; -*-
;;
;; Copyright (C) 2025 Pierre-Henry FRÖHRING
;; Author: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Maintainer: Pierre-Henry FRÖHRING <contact@phfrohring.com>
;; Homepage: https://github.com/phf-1/total-recall
;; Package-Version: 0.9
;; Package-Requires: ((emacs "29.4"))
;; SPDX-License-Identifier: GPL-3.0-or-later
;;
;; This program is free software; you can redistribute it and/or modify
;; it under the terms of the GNU General Public License as published by
;; the Free Software Foundation, either version 3 of the License, or
;; (at your option) any later version.
;;
;; This file is NOT part of GNU Emacs.
;;
;;; Commentary:
;;
;; <<commentary>>
;;
;;; Code:
#+end_src

* Dependencies

#+begin_src emacs-lisp
;; Dependencies

(unless (sqlite-available-p)
  (error "Emacs must be compiled with built-in support for SQLite databases"))
(require 'cl-generic)
(require 'org)
(require 'time-date)
(require 'parse-time)
(require 'org-element)
(require 'cl-lib)
#+end_src

* Configuration

#+begin_src emacs-lisp
;; Configuration

(defgroup total-recall nil
  "Customization options for Total Recall.
This package provides `total-recall' for spaced repetition in Emacs."
  :group 'convenience
  :prefix "total-recall-")

(defcustom total-recall-root (expand-file-name "~")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-db-path (file-name-concat (expand-file-name user-emacs-directory) "total-recall-test.sqlite3")
  ""
  :type 'string
  :group 'total-recall)

(defcustom total-recall-io-buffer-name "*TotalRecall report buffer*"
  ""
  :type 'string
  :group 'total-recall)
#+end_src

* Actor
** specification

- Tx :≡ State Message Actor → Message × State × Tx
- InitState :≡ Any → State
- Actor : init:InitState tx:Tx → Actor(init tx)
  - π : State → π
  - α : π
  - send α msg : Any

** implementation

#+begin_src emacs-lisp
;; Actor

(defmacro total-recall--Actor (init name)
  `(defun ,name (data)
     (let* ((memory (funcall ,init data))
            (self (lambda (msg)
                    (let* ((compiler (gethash 'compiler memory))
                           (stack (puthash 'stack (funcall compiler msg) memory)))
                      (while (not (null stack))
                        (puthash 'stack (cdr stack) memory)
                        (funcall (gethash 'exec memory) memory (car stack))
                        (setq stack (gethash 'stack memory)))
                      (gethash 'out memory)))))
       (puthash 'self self memory)
       self)))

(defun total-recall--send (actor msg) (funcall actor msg))

(defun total-recall--Actor-memory (compiler exec)
  (let ((memory (make-hash-table :test 'eq)))
    (puthash 'compiler compiler memory)
    (puthash 'exec exec memory)
    (puthash 'stack '() memory)
    (puthash 'out nil memory)
    memory))
#+end_src

** test

See: [[ref:3ca40a21-019b-4bba-b18b-bcec7282b445][Clock]]

* Clock
:PROPERTIES:
:ID:       3ca40a21-019b-4bba-b18b-bcec7282b445
:END:

** specification

- Clock : Nat → Clock
  - π#time() : Nat
  - π#tick() : Clock

** implementation

#+begin_src emacs-lisp
;; Clock
(total-recall--Actor
 #'total-recall--Clock-init
 total-recall--Clock)

;;;; Interface
(defun total-recall--Clock-read (clock)
  (total-recall--send clock 'read))

(defun total-recall--Clock-tick (clock)
  (total-recall--send clock 'tick))

(defun total-recall--Clock-tick2 (clock)
  (total-recall--send clock 'tick2))

;;;; Implementation
(defun total-recall--Clock-compiler (msg)
  (pcase msg
    ('read '(read))
    ('tick '(tick))
    ('tick2 '(tick tick))
    (_ (error "Unexpected msg. %s" msg))))

(defun total-recall--Clock-exec (memory inst)
  (pcase inst
    ('read
     (let ((time (gethash 'time memory)))
       (puthash 'out time memory)))

    ('tick
     (let ((time (gethash 'time memory)))
       (puthash 'time (+ time 1) memory)
       (puthash 'out (gethash 'self memory) memory)))

    (_ (error "Unexpected instruction. %s" inst))))

(defun total-recall--Clock-init (time)
  (let ((memory (total-recall--Actor-memory
                 #'total-recall--Clock-compiler
                 #'total-recall--Clock-exec)))
    (puthash 'time time memory)
    memory))
#+end_src

** test
:PROPERTIES:
:header-args:emacs-lisp+: :tangle "total-recall-test.el"
:END:

#+begin_src emacs-lisp
(require 'total-recall)
(require 'ert)

(ert-deftest total-recall--Clock ()
  (let ((clock (total-recall--Clock 0)))
    (should (= (total-recall--Clock-read clock) 0))
    (should (= (total-recall--Clock-read (total-recall--Clock-tick clock)) 1))
    (should (= (total-recall--Clock-read (total-recall--Clock-tick2 clock)) 3))))
#+end_src

* COMMENT Rating

- Rating#mk : Id → Rating
  - π#id() : Id

#+begin_src emacs-lisp
;; Rating
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--rating
  "Rating data structure."
  id)
#+end_src

*** rating-mk

#+begin_src emacs-lisp
(defun total-recall--rating-mk (id)
  ""
  (make-total-recall--rating :id id))
#+end_src

* COMMENT UI

- UI#mk : UI
  - π#show : Exercise → Rating | 'stop

#+begin_src emacs-lisp
;; UI
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--ui
  "UI data structure."
  id)
#+end_src

*** ui-mk

#+begin_src emacs-lisp
(defun total-recall--ui-mk (id)
  ""
  (make-total-recall--ui :id id))
#+end_src

* COMMENT Planner

- Planner#mk : DB → Planner
  - π#exercises : FilePath → List(Exercise)

#+begin_src emacs-lisp
;; Planner
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--planner
  "Planner data structure."
  id)
#+end_src

*** planner-mk

#+begin_src emacs-lisp
(defun total-recall--planner-mk (id)
  ""
  (make-total-recall--planner :id id))
#+end_src

* COMMENT Searcher

- ContentFile(root:DirPath) :≡ FilePath prefixed by root that contains at least one
  definition or exercise.

- Searcher#mk : root:DirPath → Searcher
  - π#files() : List(ContentFile(root))

#+begin_src emacs-lisp
;; Searcher
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--searcher
  "Searcher data structure."
  id)
#+end_src

*** searcher-mk

#+begin_src emacs-lisp
(defun total-recall--searcher-mk (id)
  ""
  (make-total-recall--searcher :id id))
#+end_src

* COMMENT DB

- DB#mk : FilePath → DB
  - π#save : Exercise Rating → DB
  - π#stop() : 'ok

#+begin_src emacs-lisp
;; DB
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--db
  "DB data structure."
  id)
#+end_src

*** db-mk

#+begin_src emacs-lisp
(defun total-recall--db-mk (id)
  ""
  (make-total-recall--db :id id))
#+end_src

* COMMENT Filepath

- Filepath#mk : Path → Filepath
  - π#path() : Path

#+begin_src emacs-lisp
;; Filepath
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--filepath
  "Filepath data structure."
  path)
#+end_src

*** filepath-mk

#+begin_src emacs-lisp
(defun total-recall--filepath-mk (path)
  ""
  (unless (file-regular-p path) (error "path is not a regular file. %s" path))
  (make-total-recall--filepath :path path))
#+end_src

* COMMENT Dirpath

- Dirpath#mk : Path → Dirpath
  - π#path() : Path

#+begin_src emacs-lisp
;; Dirpath
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--dirpath
  "Dirpath data structure."
  path)
#+end_src

*** dirpath-mk

#+begin_src emacs-lisp
(defun total-recall--dirpath-mk (path)
  ""
  (unless (file-directory-p path) (error "path is not a directory. %s" path))
  (make-total-recall--dirpath :path path))
#+end_src

* COMMENT IO

** specification

- IO#mk : Name → IO
  - π#buffer : String → IO
  - π#minibuffer : String → IO

** implementation

#+begin_src emacs-lisp
;; IO
(total-recall--Actor
 #'total-recall--IO-init-mk
 #'total-recall--IO-tx
 total-recall--IO)

;;;; Interface
(defun total-recall--IO-minibuffer (io string)
  (total-recall--send io `(minibuffer ,string)))

(defun total-recall--IO-buffer (io string)
  (total-recall--send io `(buffer ,string)))

(defun total-recall--IO-buffer-name (io)
  (total-recall--send io 'buffer-name))

;;;; Implementation
(defun total-recall--IO-init-mk (buffer-name)
  (get-buffer-create buffer-name))

(defun total-recall--IO-tx (buffer msg)
  (pcase msg
    (`(minibuffer ,string)
     (message "%s" string)
     `(t ,buffer ,#'total-recall--IO-tx))

    (`(buffer ,string)
     (with-current-buffer buffer
       (insert string)
       (insert "\n"))
     `(t ,buffer ,#'total-recall--IO-tx))

    ('buffer-name
     `(t ,(buffer-name buffer) ,#'total-recall--IO-tx))

    (_
     (error "Unexpected message. message = %s" msg))))
#+end_src

** test

* COMMENT Report

** specification

- Report#mk() : Report
  - π#string() : String
  - π#add : String → Report

** implementation

#+begin_src emacs-lisp
;; Report
(total-recall--Actor
 #'total-recall--report-init-mk
 #'total-recall--report-tx
 total-recall--Report)

;;;; Interface
(defun total-recall--Report-string (tr)
  (total-recall--send tr 'string))

(defun total-recall--report-add (tr line)
  (total-recall--send tr  ̀(add ,line)))

;;;; Implementation
(defun total-recall--report-init-mk ()
  '())

(defun total-recall--report-tx (lines msg)
  (pcase msg
    ('string
     `(,(string-join lines "\n") lines #'total-recall--report-tx))

    (`(add ,line)
     `(t ,(append lines line) #'total-recall--report-tx))

    (_
     (error "Unexpected message. message = %s" msg))))
#+end_src

** test

#+begin_src emacs-lisp
;; Report
#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--report
  "Report data structure."
  strings)
#+end_src

*** report-mk

#+begin_src emacs-lisp
(defun total-recall--report-mk ()
  ""
  (make-total-recall--report
   :strings '()))
#+end_src

*** report-string

#+begin_src emacs-lisp
(defun total-recall--Report-string (report)
  ""
  "report")
#+end_src

*** report-add

#+begin_src emacs-lisp
(defun total-recall--report-add (report string)
  ""
  report)
#+end_src

* COMMENT TotalRecall
** specification

- TotalRecall#mk : root:DirPath db-path:FilePath → TotalRecall
  - π#start() : Report :≡
    1. searcher :≡ Searcher#mk root
    2. db :≡ DB#mk db-path
    3. ui :≡ UI#mk()
    4. planner :≡ Planner#mk db
    5. files-counter : Nat :≡ 0
    6. exercises-counter : Nat :≡ 0
    7. report :≡ Report#mk()
    8. report#add "TotalRecall started."
    9. report#add "Definitions and exercises under #{root} will be reviewed."
    10. report#add "Review results will be saved in #{db-path}."
    11. files :≡ searcher#files()
    12. π#next-file()

** implementation

#+begin_src emacs-lisp
;; TotalRecall
(total-recall--Actor
 #'total-recall--TotalRecall-init-mk
 #'total-recall--TotalRecall-tx
 total-recall--TotalRecall)

;;;; Interface
(defun total-recall--TotalRecall-start (tr)
  (total-recall--send tr 'start))

;;;; Implementation
(defun total-recall--TotalRecall-init-mk (any)
  (pcase-let ((`(,root ,db-path) any))
    (let* ((db (total-recall--DB db-path))
           (files-counter 0)
           (exercises-counter 0)
           (searcher (total-recall--Searcher root))
           (files (total-recall--Searcher-files searcher))
           (ui (total-recall--UI t))
           (planner (total-recall--Planner db))
           (report (total-recall--Report t)))
      `(,root
        ,db-path
        ,files
        ,planner
        ,ui
        ,db
        ,files-counter
        ,exercises-counter
        ,report))))

(defun total-recall--TotalRecall-tx (state msg )
  (pcase-let ((`(,root
                 ,db-path
                 ,files
                 ,planner
                 ,ui
                 ,db
                 ,files-counter
                 ,exercises-counter
                 ,report)
               state))

    (pcase msg
      ('start
       (total-report--Report-add report "TotalRecall started.")
       (total-report--Report-add report (format "Definitions and exercises under %s will be reviewed." root))
       (total-report--Report-add report (format "Review results will be saved in %s." db-path))
       (total-recall--send self 'next-file)
       `(,report ,state ,#'total-recall--TotalRecall-tx))

      ('next-file
       (total-report--Report-add report "next-file")
       `(,report ,state ,#'total-recall--TotalRecall-tx))

      (_
       (error "Unexpected message. message = %s" msg)))))
#+end_src

** test

#+begin_src emacs-lisp

#+end_src

#+begin_src emacs-lisp
(cl-defstruct total-recall--TotalRecall
  ""
  root db-path)
#+end_src

*** total-recall-mk

#+begin_src emacs-lisp
(defun total-recall--TotalRecall-mk (root db-path)
  ""
  (make-total-recall--TotalRecall
   :root root
   :db-path db-path))
#+end_src

*** total-recall-start

- π#start() : Report :≡


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-start (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-next-file

- π#next-file() : Report :≡
  - match files
    - [ ] → π#stop()
    - [file-path] + rest →
      1. files :≡ rest
      2. report#add "Reviewing exercises from file: #{file-path}."
      3. exercises :≡ planner#exercises file-path
      4. π#next-exercise()


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-next-file (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-next-exercise

- π#next-exercise() : Report :≡
  - match exercises
    - [ ] →
      1. files-counter :≡ files-counter + 1
      2. π#next-file()
    - [exercise] + rest →
      1. exercises :≡ rest
      2. report#add "Reviewing exercise: #{string-join(exercise#path())}."
      3. match ui#show exercise
         - 'stop → π#stop()
         - rating : Rating →
           1. exercises-counter :≡ exercises-counter + 1
           2. db#save exercise rating
           3. π#next-exercise()


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-next-exercise (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

*** total-recall-stop

- π#stop() : Report :≡
  1. db#stop()
  2. report#add "Reviewing process is finished."
  3. report#add "#{exercises-counter} exercises or definitions have been reviewed from #{files-counter} files."
  4. report


#+begin_src emacs-lisp
(defun total-recall--TotalRecall-stop (total-recall)
  ""
  (total-recall--report-mk))
#+end_src

* COMMENT total-recall

- total-recall() : Proposition :≡
  1. db-path : FilePath
  2. root : DirPath
  3. io-buffer-name : Name
  4. total-recall :≡ TotalRecall#mk root db-path
  5. io :≡ IO#mk io-buffer-name
  6. report :≡ total-recall#start()
  7. io#print-to-buffer report#string()
  8. io#print-to-minibuffer "total-recall execution finished. Report written to #{io#buffer()}".

#+begin_src emacs-lisp
;; total-recall
;;;###autoload
(defun total-recall ()
  ""
  (interactive)
  (let* ((tr (total-recall--TotalRecall `(,total-recall-root ,total-recall-db-path)))
         (report (total-recall--TotalRecall-start tr))
         (io (total-recall--IO total-recall-io-buffer-name)))
    (total-recall--IO-buffer io (total-recall--Report-string report))
    (total-recall--IO-minibuffer io (format "total-recall execution finished. Report written to %s" (total-recall--IO-buffer-name io)))))
#+end_src

* Footer

#+begin_src emacs-lisp
(provide 'total-recall)

;;; total-recall.el ends here

;; Local Variables:
;; coding: utf-8
;; byte-compile-docstring-max-column: 80
;; require-final-newline: t
;; sentence-end-double-space: nil
;; indent-tabs-mode: nil
;; End:
#+end_src
